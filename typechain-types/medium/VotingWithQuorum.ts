/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface VotingWithQuorumInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "addProposal"
      | "getWinningProposal"
      | "hasVoted"
      | "owner"
      | "proposals"
      | "quorumPercent"
      | "registerVoter"
      | "registeredVoters"
      | "setQuorumPercent"
      | "startVoting"
      | "totalVoters"
      | "vote"
      | "votesCast"
      | "votingStarted"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ProposalAccepted"
      | "ProposalAdded"
      | "QuorumChanged"
      | "VoteCast"
      | "VoterRegistered"
      | "VotingStarted"
  ): EventFragment;

  encodeFunctionData(functionFragment: "addProposal", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getWinningProposal",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hasVoted",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proposals",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "quorumPercent",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "registerVoter",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registeredVoters",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setQuorumPercent",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "startVoting",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalVoters",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "vote", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "votesCast", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "votingStarted",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "addProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWinningProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hasVoted", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "proposals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "quorumPercent",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerVoter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registeredVoters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setQuorumPercent",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startVoting",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalVoters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "vote", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "votesCast", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "votingStarted",
    data: BytesLike
  ): Result;
}

export namespace ProposalAcceptedEvent {
  export type InputTuple = [description: string];
  export type OutputTuple = [description: string];
  export interface OutputObject {
    description: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ProposalAddedEvent {
  export type InputTuple = [description: string];
  export type OutputTuple = [description: string];
  export interface OutputObject {
    description: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace QuorumChangedEvent {
  export type InputTuple = [newQuorumPercent: BigNumberish];
  export type OutputTuple = [newQuorumPercent: bigint];
  export interface OutputObject {
    newQuorumPercent: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VoteCastEvent {
  export type InputTuple = [voter: AddressLike, proposalIndex: BigNumberish];
  export type OutputTuple = [voter: string, proposalIndex: bigint];
  export interface OutputObject {
    voter: string;
    proposalIndex: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VoterRegisteredEvent {
  export type InputTuple = [voter: AddressLike];
  export type OutputTuple = [voter: string];
  export interface OutputObject {
    voter: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VotingStartedEvent {
  export type InputTuple = [];
  export type OutputTuple = [];
  export interface OutputObject {}
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface VotingWithQuorum extends BaseContract {
  connect(runner?: ContractRunner | null): VotingWithQuorum;
  waitForDeployment(): Promise<this>;

  interface: VotingWithQuorumInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  addProposal: TypedContractMethod<[description: string], [void], "nonpayable">;

  getWinningProposal: TypedContractMethod<
    [],
    [[string, boolean] & { description: string; accepted: boolean }],
    "view"
  >;

  hasVoted: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  owner: TypedContractMethod<[], [string], "view">;

  proposals: TypedContractMethod<
    [arg0: BigNumberish],
    [[string, bigint] & { description: string; voteCount: bigint }],
    "view"
  >;

  quorumPercent: TypedContractMethod<[], [bigint], "view">;

  registerVoter: TypedContractMethod<
    [voter: AddressLike],
    [void],
    "nonpayable"
  >;

  registeredVoters: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  setQuorumPercent: TypedContractMethod<
    [newQuorumPercent: BigNumberish],
    [void],
    "nonpayable"
  >;

  startVoting: TypedContractMethod<[], [void], "nonpayable">;

  totalVoters: TypedContractMethod<[], [bigint], "view">;

  vote: TypedContractMethod<
    [proposalIndex: BigNumberish],
    [void],
    "nonpayable"
  >;

  votesCast: TypedContractMethod<[], [bigint], "view">;

  votingStarted: TypedContractMethod<[], [boolean], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "addProposal"
  ): TypedContractMethod<[description: string], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getWinningProposal"
  ): TypedContractMethod<
    [],
    [[string, boolean] & { description: string; accepted: boolean }],
    "view"
  >;
  getFunction(
    nameOrSignature: "hasVoted"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "proposals"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [[string, bigint] & { description: string; voteCount: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "quorumPercent"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "registerVoter"
  ): TypedContractMethod<[voter: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "registeredVoters"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "setQuorumPercent"
  ): TypedContractMethod<
    [newQuorumPercent: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "startVoting"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "totalVoters"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "vote"
  ): TypedContractMethod<[proposalIndex: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "votesCast"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "votingStarted"
  ): TypedContractMethod<[], [boolean], "view">;

  getEvent(
    key: "ProposalAccepted"
  ): TypedContractEvent<
    ProposalAcceptedEvent.InputTuple,
    ProposalAcceptedEvent.OutputTuple,
    ProposalAcceptedEvent.OutputObject
  >;
  getEvent(
    key: "ProposalAdded"
  ): TypedContractEvent<
    ProposalAddedEvent.InputTuple,
    ProposalAddedEvent.OutputTuple,
    ProposalAddedEvent.OutputObject
  >;
  getEvent(
    key: "QuorumChanged"
  ): TypedContractEvent<
    QuorumChangedEvent.InputTuple,
    QuorumChangedEvent.OutputTuple,
    QuorumChangedEvent.OutputObject
  >;
  getEvent(
    key: "VoteCast"
  ): TypedContractEvent<
    VoteCastEvent.InputTuple,
    VoteCastEvent.OutputTuple,
    VoteCastEvent.OutputObject
  >;
  getEvent(
    key: "VoterRegistered"
  ): TypedContractEvent<
    VoterRegisteredEvent.InputTuple,
    VoterRegisteredEvent.OutputTuple,
    VoterRegisteredEvent.OutputObject
  >;
  getEvent(
    key: "VotingStarted"
  ): TypedContractEvent<
    VotingStartedEvent.InputTuple,
    VotingStartedEvent.OutputTuple,
    VotingStartedEvent.OutputObject
  >;

  filters: {
    "ProposalAccepted(string)": TypedContractEvent<
      ProposalAcceptedEvent.InputTuple,
      ProposalAcceptedEvent.OutputTuple,
      ProposalAcceptedEvent.OutputObject
    >;
    ProposalAccepted: TypedContractEvent<
      ProposalAcceptedEvent.InputTuple,
      ProposalAcceptedEvent.OutputTuple,
      ProposalAcceptedEvent.OutputObject
    >;

    "ProposalAdded(string)": TypedContractEvent<
      ProposalAddedEvent.InputTuple,
      ProposalAddedEvent.OutputTuple,
      ProposalAddedEvent.OutputObject
    >;
    ProposalAdded: TypedContractEvent<
      ProposalAddedEvent.InputTuple,
      ProposalAddedEvent.OutputTuple,
      ProposalAddedEvent.OutputObject
    >;

    "QuorumChanged(uint256)": TypedContractEvent<
      QuorumChangedEvent.InputTuple,
      QuorumChangedEvent.OutputTuple,
      QuorumChangedEvent.OutputObject
    >;
    QuorumChanged: TypedContractEvent<
      QuorumChangedEvent.InputTuple,
      QuorumChangedEvent.OutputTuple,
      QuorumChangedEvent.OutputObject
    >;

    "VoteCast(address,uint256)": TypedContractEvent<
      VoteCastEvent.InputTuple,
      VoteCastEvent.OutputTuple,
      VoteCastEvent.OutputObject
    >;
    VoteCast: TypedContractEvent<
      VoteCastEvent.InputTuple,
      VoteCastEvent.OutputTuple,
      VoteCastEvent.OutputObject
    >;

    "VoterRegistered(address)": TypedContractEvent<
      VoterRegisteredEvent.InputTuple,
      VoterRegisteredEvent.OutputTuple,
      VoterRegisteredEvent.OutputObject
    >;
    VoterRegistered: TypedContractEvent<
      VoterRegisteredEvent.InputTuple,
      VoterRegisteredEvent.OutputTuple,
      VoterRegisteredEvent.OutputObject
    >;

    "VotingStarted()": TypedContractEvent<
      VotingStartedEvent.InputTuple,
      VotingStartedEvent.OutputTuple,
      VotingStartedEvent.OutputObject
    >;
    VotingStarted: TypedContractEvent<
      VotingStartedEvent.InputTuple,
      VotingStartedEvent.OutputTuple,
      VotingStartedEvent.OutputObject
    >;
  };
}
