/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace IFluidVaultResolver {
  export type TokensStruct = { token0: AddressLike; token1: AddressLike };

  export type TokensStructOutput = [token0: string, token1: string] & {
    token0: string;
    token1: string;
  };

  export type ConstantViewsStruct = {
    liquidity: AddressLike;
    factory: AddressLike;
    operateImplementation: AddressLike;
    adminImplementation: AddressLike;
    secondaryImplementation: AddressLike;
    deployer: AddressLike;
    supply: AddressLike;
    borrow: AddressLike;
    supplyToken: IFluidVaultResolver.TokensStruct;
    borrowToken: IFluidVaultResolver.TokensStruct;
    vaultId: BigNumberish;
    vaultType: BigNumberish;
    supplyExchangePriceSlot: BytesLike;
    borrowExchangePriceSlot: BytesLike;
    userSupplySlot: BytesLike;
    userBorrowSlot: BytesLike;
  };

  export type ConstantViewsStructOutput = [
    liquidity: string,
    factory: string,
    operateImplementation: string,
    adminImplementation: string,
    secondaryImplementation: string,
    deployer: string,
    supply: string,
    borrow: string,
    supplyToken: IFluidVaultResolver.TokensStructOutput,
    borrowToken: IFluidVaultResolver.TokensStructOutput,
    vaultId: bigint,
    vaultType: bigint,
    supplyExchangePriceSlot: string,
    borrowExchangePriceSlot: string,
    userSupplySlot: string,
    userBorrowSlot: string
  ] & {
    liquidity: string;
    factory: string;
    operateImplementation: string;
    adminImplementation: string;
    secondaryImplementation: string;
    deployer: string;
    supply: string;
    borrow: string;
    supplyToken: IFluidVaultResolver.TokensStructOutput;
    borrowToken: IFluidVaultResolver.TokensStructOutput;
    vaultId: bigint;
    vaultType: bigint;
    supplyExchangePriceSlot: string;
    borrowExchangePriceSlot: string;
    userSupplySlot: string;
    userBorrowSlot: string;
  };

  export type ConfigsStruct = {
    supplyRateMagnifier: BigNumberish;
    borrowRateMagnifier: BigNumberish;
    collateralFactor: BigNumberish;
    liquidationThreshold: BigNumberish;
    liquidationMaxLimit: BigNumberish;
    withdrawalGap: BigNumberish;
    liquidationPenalty: BigNumberish;
    borrowFee: BigNumberish;
    oracle: AddressLike;
    oraclePriceOperate: BigNumberish;
    oraclePriceLiquidate: BigNumberish;
    rebalancer: AddressLike;
    lastUpdateTimestamp: BigNumberish;
  };

  export type ConfigsStructOutput = [
    supplyRateMagnifier: bigint,
    borrowRateMagnifier: bigint,
    collateralFactor: bigint,
    liquidationThreshold: bigint,
    liquidationMaxLimit: bigint,
    withdrawalGap: bigint,
    liquidationPenalty: bigint,
    borrowFee: bigint,
    oracle: string,
    oraclePriceOperate: bigint,
    oraclePriceLiquidate: bigint,
    rebalancer: string,
    lastUpdateTimestamp: bigint
  ] & {
    supplyRateMagnifier: bigint;
    borrowRateMagnifier: bigint;
    collateralFactor: bigint;
    liquidationThreshold: bigint;
    liquidationMaxLimit: bigint;
    withdrawalGap: bigint;
    liquidationPenalty: bigint;
    borrowFee: bigint;
    oracle: string;
    oraclePriceOperate: bigint;
    oraclePriceLiquidate: bigint;
    rebalancer: string;
    lastUpdateTimestamp: bigint;
  };

  export type ExchangePricesAndRatesStruct = {
    lastStoredLiquiditySupplyExchangePrice: BigNumberish;
    lastStoredLiquidityBorrowExchangePrice: BigNumberish;
    lastStoredVaultSupplyExchangePrice: BigNumberish;
    lastStoredVaultBorrowExchangePrice: BigNumberish;
    liquiditySupplyExchangePrice: BigNumberish;
    liquidityBorrowExchangePrice: BigNumberish;
    vaultSupplyExchangePrice: BigNumberish;
    vaultBorrowExchangePrice: BigNumberish;
    supplyRateLiquidity: BigNumberish;
    borrowRateLiquidity: BigNumberish;
    supplyRateVault: BigNumberish;
    borrowRateVault: BigNumberish;
    rewardsOrFeeRateSupply: BigNumberish;
    rewardsOrFeeRateBorrow: BigNumberish;
  };

  export type ExchangePricesAndRatesStructOutput = [
    lastStoredLiquiditySupplyExchangePrice: bigint,
    lastStoredLiquidityBorrowExchangePrice: bigint,
    lastStoredVaultSupplyExchangePrice: bigint,
    lastStoredVaultBorrowExchangePrice: bigint,
    liquiditySupplyExchangePrice: bigint,
    liquidityBorrowExchangePrice: bigint,
    vaultSupplyExchangePrice: bigint,
    vaultBorrowExchangePrice: bigint,
    supplyRateLiquidity: bigint,
    borrowRateLiquidity: bigint,
    supplyRateVault: bigint,
    borrowRateVault: bigint,
    rewardsOrFeeRateSupply: bigint,
    rewardsOrFeeRateBorrow: bigint
  ] & {
    lastStoredLiquiditySupplyExchangePrice: bigint;
    lastStoredLiquidityBorrowExchangePrice: bigint;
    lastStoredVaultSupplyExchangePrice: bigint;
    lastStoredVaultBorrowExchangePrice: bigint;
    liquiditySupplyExchangePrice: bigint;
    liquidityBorrowExchangePrice: bigint;
    vaultSupplyExchangePrice: bigint;
    vaultBorrowExchangePrice: bigint;
    supplyRateLiquidity: bigint;
    borrowRateLiquidity: bigint;
    supplyRateVault: bigint;
    borrowRateVault: bigint;
    rewardsOrFeeRateSupply: bigint;
    rewardsOrFeeRateBorrow: bigint;
  };

  export type TotalSupplyAndBorrowStruct = {
    totalSupplyVault: BigNumberish;
    totalBorrowVault: BigNumberish;
    totalSupplyLiquidityOrDex: BigNumberish;
    totalBorrowLiquidityOrDex: BigNumberish;
    absorbedSupply: BigNumberish;
    absorbedBorrow: BigNumberish;
  };

  export type TotalSupplyAndBorrowStructOutput = [
    totalSupplyVault: bigint,
    totalBorrowVault: bigint,
    totalSupplyLiquidityOrDex: bigint,
    totalBorrowLiquidityOrDex: bigint,
    absorbedSupply: bigint,
    absorbedBorrow: bigint
  ] & {
    totalSupplyVault: bigint;
    totalBorrowVault: bigint;
    totalSupplyLiquidityOrDex: bigint;
    totalBorrowLiquidityOrDex: bigint;
    absorbedSupply: bigint;
    absorbedBorrow: bigint;
  };

  export type LimitsAndAvailabilityStruct = {
    withdrawLimit: BigNumberish;
    withdrawableUntilLimit: BigNumberish;
    withdrawable: BigNumberish;
    borrowLimit: BigNumberish;
    borrowableUntilLimit: BigNumberish;
    borrowable: BigNumberish;
    borrowLimitUtilization: BigNumberish;
    minimumBorrowing: BigNumberish;
  };

  export type LimitsAndAvailabilityStructOutput = [
    withdrawLimit: bigint,
    withdrawableUntilLimit: bigint,
    withdrawable: bigint,
    borrowLimit: bigint,
    borrowableUntilLimit: bigint,
    borrowable: bigint,
    borrowLimitUtilization: bigint,
    minimumBorrowing: bigint
  ] & {
    withdrawLimit: bigint;
    withdrawableUntilLimit: bigint;
    withdrawable: bigint;
    borrowLimit: bigint;
    borrowableUntilLimit: bigint;
    borrowable: bigint;
    borrowLimitUtilization: bigint;
    minimumBorrowing: bigint;
  };

  export type CurrentBranchStateStruct = {
    status: BigNumberish;
    minimaTick: BigNumberish;
    debtFactor: BigNumberish;
    partials: BigNumberish;
    debtLiquidity: BigNumberish;
    baseBranchId: BigNumberish;
    baseBranchMinima: BigNumberish;
  };

  export type CurrentBranchStateStructOutput = [
    status: bigint,
    minimaTick: bigint,
    debtFactor: bigint,
    partials: bigint,
    debtLiquidity: bigint,
    baseBranchId: bigint,
    baseBranchMinima: bigint
  ] & {
    status: bigint;
    minimaTick: bigint;
    debtFactor: bigint;
    partials: bigint;
    debtLiquidity: bigint;
    baseBranchId: bigint;
    baseBranchMinima: bigint;
  };

  export type VaultStateStruct = {
    totalPositions: BigNumberish;
    topTick: BigNumberish;
    currentBranch: BigNumberish;
    totalBranch: BigNumberish;
    totalBorrow: BigNumberish;
    totalSupply: BigNumberish;
    currentBranchState: IFluidVaultResolver.CurrentBranchStateStruct;
  };

  export type VaultStateStructOutput = [
    totalPositions: bigint,
    topTick: bigint,
    currentBranch: bigint,
    totalBranch: bigint,
    totalBorrow: bigint,
    totalSupply: bigint,
    currentBranchState: IFluidVaultResolver.CurrentBranchStateStructOutput
  ] & {
    totalPositions: bigint;
    topTick: bigint;
    currentBranch: bigint;
    totalBranch: bigint;
    totalBorrow: bigint;
    totalSupply: bigint;
    currentBranchState: IFluidVaultResolver.CurrentBranchStateStructOutput;
  };

  export type UserSupplyDataStruct = {
    modeWithInterest: boolean;
    supply: BigNumberish;
    withdrawalLimit: BigNumberish;
    lastUpdateTimestamp: BigNumberish;
    expandPercent: BigNumberish;
    expandDuration: BigNumberish;
    baseWithdrawalLimit: BigNumberish;
    withdrawableUntilLimit: BigNumberish;
    withdrawable: BigNumberish;
  };

  export type UserSupplyDataStructOutput = [
    modeWithInterest: boolean,
    supply: bigint,
    withdrawalLimit: bigint,
    lastUpdateTimestamp: bigint,
    expandPercent: bigint,
    expandDuration: bigint,
    baseWithdrawalLimit: bigint,
    withdrawableUntilLimit: bigint,
    withdrawable: bigint
  ] & {
    modeWithInterest: boolean;
    supply: bigint;
    withdrawalLimit: bigint;
    lastUpdateTimestamp: bigint;
    expandPercent: bigint;
    expandDuration: bigint;
    baseWithdrawalLimit: bigint;
    withdrawableUntilLimit: bigint;
    withdrawable: bigint;
  };

  export type UserBorrowDataStruct = {
    modeWithInterest: boolean;
    borrow: BigNumberish;
    borrowLimit: BigNumberish;
    lastUpdateTimestamp: BigNumberish;
    expandPercent: BigNumberish;
    expandDuration: BigNumberish;
    baseBorrowLimit: BigNumberish;
    maxBorrowLimit: BigNumberish;
    borrowableUntilLimit: BigNumberish;
    borrowable: BigNumberish;
    borrowLimitUtilization: BigNumberish;
  };

  export type UserBorrowDataStructOutput = [
    modeWithInterest: boolean,
    borrow: bigint,
    borrowLimit: bigint,
    lastUpdateTimestamp: bigint,
    expandPercent: bigint,
    expandDuration: bigint,
    baseBorrowLimit: bigint,
    maxBorrowLimit: bigint,
    borrowableUntilLimit: bigint,
    borrowable: bigint,
    borrowLimitUtilization: bigint
  ] & {
    modeWithInterest: boolean;
    borrow: bigint;
    borrowLimit: bigint;
    lastUpdateTimestamp: bigint;
    expandPercent: bigint;
    expandDuration: bigint;
    baseBorrowLimit: bigint;
    maxBorrowLimit: bigint;
    borrowableUntilLimit: bigint;
    borrowable: bigint;
    borrowLimitUtilization: bigint;
  };

  export type VaultEntireDataStruct = {
    vault: AddressLike;
    isSmartCol: boolean;
    isSmartDebt: boolean;
    constantVariables: IFluidVaultResolver.ConstantViewsStruct;
    configs: IFluidVaultResolver.ConfigsStruct;
    exchangePricesAndRates: IFluidVaultResolver.ExchangePricesAndRatesStruct;
    totalSupplyAndBorrow: IFluidVaultResolver.TotalSupplyAndBorrowStruct;
    limitsAndAvailability: IFluidVaultResolver.LimitsAndAvailabilityStruct;
    vaultState: IFluidVaultResolver.VaultStateStruct;
    liquidityUserSupplyData: IFluidVaultResolver.UserSupplyDataStruct;
    liquidityUserBorrowData: IFluidVaultResolver.UserBorrowDataStruct;
  };

  export type VaultEntireDataStructOutput = [
    vault: string,
    isSmartCol: boolean,
    isSmartDebt: boolean,
    constantVariables: IFluidVaultResolver.ConstantViewsStructOutput,
    configs: IFluidVaultResolver.ConfigsStructOutput,
    exchangePricesAndRates: IFluidVaultResolver.ExchangePricesAndRatesStructOutput,
    totalSupplyAndBorrow: IFluidVaultResolver.TotalSupplyAndBorrowStructOutput,
    limitsAndAvailability: IFluidVaultResolver.LimitsAndAvailabilityStructOutput,
    vaultState: IFluidVaultResolver.VaultStateStructOutput,
    liquidityUserSupplyData: IFluidVaultResolver.UserSupplyDataStructOutput,
    liquidityUserBorrowData: IFluidVaultResolver.UserBorrowDataStructOutput
  ] & {
    vault: string;
    isSmartCol: boolean;
    isSmartDebt: boolean;
    constantVariables: IFluidVaultResolver.ConstantViewsStructOutput;
    configs: IFluidVaultResolver.ConfigsStructOutput;
    exchangePricesAndRates: IFluidVaultResolver.ExchangePricesAndRatesStructOutput;
    totalSupplyAndBorrow: IFluidVaultResolver.TotalSupplyAndBorrowStructOutput;
    limitsAndAvailability: IFluidVaultResolver.LimitsAndAvailabilityStructOutput;
    vaultState: IFluidVaultResolver.VaultStateStructOutput;
    liquidityUserSupplyData: IFluidVaultResolver.UserSupplyDataStructOutput;
    liquidityUserBorrowData: IFluidVaultResolver.UserBorrowDataStructOutput;
  };

  export type UserPositionStruct = {
    nftId: BigNumberish;
    owner: AddressLike;
    isLiquidated: boolean;
    isSupplyPosition: boolean;
    tick: BigNumberish;
    tickId: BigNumberish;
    beforeSupply: BigNumberish;
    beforeBorrow: BigNumberish;
    beforeDustBorrow: BigNumberish;
    supply: BigNumberish;
    borrow: BigNumberish;
    dustBorrow: BigNumberish;
  };

  export type UserPositionStructOutput = [
    nftId: bigint,
    owner: string,
    isLiquidated: boolean,
    isSupplyPosition: boolean,
    tick: bigint,
    tickId: bigint,
    beforeSupply: bigint,
    beforeBorrow: bigint,
    beforeDustBorrow: bigint,
    supply: bigint,
    borrow: bigint,
    dustBorrow: bigint
  ] & {
    nftId: bigint;
    owner: string;
    isLiquidated: boolean;
    isSupplyPosition: boolean;
    tick: bigint;
    tickId: bigint;
    beforeSupply: bigint;
    beforeBorrow: bigint;
    beforeDustBorrow: bigint;
    supply: bigint;
    borrow: bigint;
    dustBorrow: bigint;
  };
}

export interface IFluidVaultResolverInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "getAllVaultsAddresses"
      | "getVaultAddress"
      | "getVaultEntireData"
      | "getVaultId"
      | "positionByNftId"
      | "positionsNftIdOfUser"
      | "vaultByNftId"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getAllVaultsAddresses",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultAddress",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultEntireData",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultId",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "positionByNftId",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "positionsNftIdOfUser",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "vaultByNftId",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "getAllVaultsAddresses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultEntireData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getVaultId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "positionByNftId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "positionsNftIdOfUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vaultByNftId",
    data: BytesLike
  ): Result;
}

export interface IFluidVaultResolver extends BaseContract {
  connect(runner?: ContractRunner | null): IFluidVaultResolver;
  waitForDeployment(): Promise<this>;

  interface: IFluidVaultResolverInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getAllVaultsAddresses: TypedContractMethod<[], [string[]], "view">;

  getVaultAddress: TypedContractMethod<
    [vaultId_: BigNumberish],
    [string],
    "view"
  >;

  getVaultEntireData: TypedContractMethod<
    [vault_: AddressLike],
    [IFluidVaultResolver.VaultEntireDataStructOutput],
    "view"
  >;

  getVaultId: TypedContractMethod<[vault_: AddressLike], [bigint], "view">;

  positionByNftId: TypedContractMethod<
    [nftId_: BigNumberish],
    [
      [
        IFluidVaultResolver.UserPositionStructOutput,
        IFluidVaultResolver.VaultEntireDataStructOutput
      ] & {
        userPosition_: IFluidVaultResolver.UserPositionStructOutput;
        vaultData_: IFluidVaultResolver.VaultEntireDataStructOutput;
      }
    ],
    "view"
  >;

  positionsNftIdOfUser: TypedContractMethod<
    [user_: AddressLike],
    [bigint[]],
    "view"
  >;

  vaultByNftId: TypedContractMethod<[nftId_: BigNumberish], [string], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "getAllVaultsAddresses"
  ): TypedContractMethod<[], [string[]], "view">;
  getFunction(
    nameOrSignature: "getVaultAddress"
  ): TypedContractMethod<[vaultId_: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "getVaultEntireData"
  ): TypedContractMethod<
    [vault_: AddressLike],
    [IFluidVaultResolver.VaultEntireDataStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getVaultId"
  ): TypedContractMethod<[vault_: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "positionByNftId"
  ): TypedContractMethod<
    [nftId_: BigNumberish],
    [
      [
        IFluidVaultResolver.UserPositionStructOutput,
        IFluidVaultResolver.VaultEntireDataStructOutput
      ] & {
        userPosition_: IFluidVaultResolver.UserPositionStructOutput;
        vaultData_: IFluidVaultResolver.VaultEntireDataStructOutput;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "positionsNftIdOfUser"
  ): TypedContractMethod<[user_: AddressLike], [bigint[]], "view">;
  getFunction(
    nameOrSignature: "vaultByNftId"
  ): TypedContractMethod<[nftId_: BigNumberish], [string], "view">;

  filters: {};
}
