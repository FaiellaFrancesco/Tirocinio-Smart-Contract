/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace FluidView {
  export type FTokenDataStruct = {
    tokenAddress: AddressLike;
    isNativeUnderlying: boolean;
    name: string;
    symbol: string;
    decimals: BigNumberish;
    asset: AddressLike;
    totalAssets: BigNumberish;
    totalSupply: BigNumberish;
    convertToShares: BigNumberish;
    convertToAssets: BigNumberish;
    rewardsRate: BigNumberish;
    supplyRate: BigNumberish;
    withdrawable: BigNumberish;
    modeWithInterest: boolean;
    expandPercent: BigNumberish;
    expandDuration: BigNumberish;
  };

  export type FTokenDataStructOutput = [
    tokenAddress: string,
    isNativeUnderlying: boolean,
    name: string,
    symbol: string,
    decimals: bigint,
    asset: string,
    totalAssets: bigint,
    totalSupply: bigint,
    convertToShares: bigint,
    convertToAssets: bigint,
    rewardsRate: bigint,
    supplyRate: bigint,
    withdrawable: bigint,
    modeWithInterest: boolean,
    expandPercent: bigint,
    expandDuration: bigint
  ] & {
    tokenAddress: string;
    isNativeUnderlying: boolean;
    name: string;
    symbol: string;
    decimals: bigint;
    asset: string;
    totalAssets: bigint;
    totalSupply: bigint;
    convertToShares: bigint;
    convertToAssets: bigint;
    rewardsRate: bigint;
    supplyRate: bigint;
    withdrawable: bigint;
    modeWithInterest: boolean;
    expandPercent: bigint;
    expandDuration: bigint;
  };

  export type UserEarnPositionStruct = {
    fTokenShares: BigNumberish;
    underlyingAssets: BigNumberish;
    underlyingBalance: BigNumberish;
    allowance: BigNumberish;
  };

  export type UserEarnPositionStructOutput = [
    fTokenShares: bigint,
    underlyingAssets: bigint,
    underlyingBalance: bigint,
    allowance: bigint
  ] & {
    fTokenShares: bigint;
    underlyingAssets: bigint;
    underlyingBalance: bigint;
    allowance: bigint;
  };

  export type UserPositionStruct = {
    nftId: BigNumberish;
    owner: AddressLike;
    isLiquidated: boolean;
    isSupplyPosition: boolean;
    supply: BigNumberish;
    borrow: BigNumberish;
    ratio: BigNumberish;
    tick: BigNumberish;
    tickId: BigNumberish;
  };

  export type UserPositionStructOutput = [
    nftId: bigint,
    owner: string,
    isLiquidated: boolean,
    isSupplyPosition: boolean,
    supply: bigint,
    borrow: bigint,
    ratio: bigint,
    tick: bigint,
    tickId: bigint
  ] & {
    nftId: bigint;
    owner: string;
    isLiquidated: boolean;
    isSupplyPosition: boolean;
    supply: bigint;
    borrow: bigint;
    ratio: bigint;
    tick: bigint;
    tickId: bigint;
  };

  export type DexSupplyDataStruct = {
    dexPool: AddressLike;
    dexId: BigNumberish;
    fee: BigNumberish;
    lastStoredPrice: BigNumberish;
    centerPrice: BigNumberish;
    token0Utilization: BigNumberish;
    token1Utilization: BigNumberish;
    totalSupplyShares: BigNumberish;
    maxSupplyShares: BigNumberish;
    token0Supplied: BigNumberish;
    token1Supplied: BigNumberish;
    sharesWithdrawable: BigNumberish;
    token0Withdrawable: BigNumberish;
    token1Withdrawable: BigNumberish;
    token0PerSupplyShare: BigNumberish;
    token1PerSupplyShare: BigNumberish;
    token0SupplyRate: BigNumberish;
    token1SupplyRate: BigNumberish;
    quoteToken: AddressLike;
    quoteTokensPerShare: BigNumberish;
    supplyToken0Reserves: BigNumberish;
    supplyToken1Reserves: BigNumberish;
  };

  export type DexSupplyDataStructOutput = [
    dexPool: string,
    dexId: bigint,
    fee: bigint,
    lastStoredPrice: bigint,
    centerPrice: bigint,
    token0Utilization: bigint,
    token1Utilization: bigint,
    totalSupplyShares: bigint,
    maxSupplyShares: bigint,
    token0Supplied: bigint,
    token1Supplied: bigint,
    sharesWithdrawable: bigint,
    token0Withdrawable: bigint,
    token1Withdrawable: bigint,
    token0PerSupplyShare: bigint,
    token1PerSupplyShare: bigint,
    token0SupplyRate: bigint,
    token1SupplyRate: bigint,
    quoteToken: string,
    quoteTokensPerShare: bigint,
    supplyToken0Reserves: bigint,
    supplyToken1Reserves: bigint
  ] & {
    dexPool: string;
    dexId: bigint;
    fee: bigint;
    lastStoredPrice: bigint;
    centerPrice: bigint;
    token0Utilization: bigint;
    token1Utilization: bigint;
    totalSupplyShares: bigint;
    maxSupplyShares: bigint;
    token0Supplied: bigint;
    token1Supplied: bigint;
    sharesWithdrawable: bigint;
    token0Withdrawable: bigint;
    token1Withdrawable: bigint;
    token0PerSupplyShare: bigint;
    token1PerSupplyShare: bigint;
    token0SupplyRate: bigint;
    token1SupplyRate: bigint;
    quoteToken: string;
    quoteTokensPerShare: bigint;
    supplyToken0Reserves: bigint;
    supplyToken1Reserves: bigint;
  };

  export type DexBorrowDataStruct = {
    dexPool: AddressLike;
    dexId: BigNumberish;
    fee: BigNumberish;
    lastStoredPrice: BigNumberish;
    centerPrice: BigNumberish;
    token0Utilization: BigNumberish;
    token1Utilization: BigNumberish;
    totalBorrowShares: BigNumberish;
    maxBorrowShares: BigNumberish;
    token0Borrowed: BigNumberish;
    token1Borrowed: BigNumberish;
    sharesBorrowable: BigNumberish;
    token0Borrowable: BigNumberish;
    token1Borrowable: BigNumberish;
    token0PerBorrowShare: BigNumberish;
    token1PerBorrowShare: BigNumberish;
    token0BorrowRate: BigNumberish;
    token1BorrowRate: BigNumberish;
    quoteToken: AddressLike;
    quoteTokensPerShare: BigNumberish;
    borrowToken0Reserves: BigNumberish;
    borrowToken1Reserves: BigNumberish;
  };

  export type DexBorrowDataStructOutput = [
    dexPool: string,
    dexId: bigint,
    fee: bigint,
    lastStoredPrice: bigint,
    centerPrice: bigint,
    token0Utilization: bigint,
    token1Utilization: bigint,
    totalBorrowShares: bigint,
    maxBorrowShares: bigint,
    token0Borrowed: bigint,
    token1Borrowed: bigint,
    sharesBorrowable: bigint,
    token0Borrowable: bigint,
    token1Borrowable: bigint,
    token0PerBorrowShare: bigint,
    token1PerBorrowShare: bigint,
    token0BorrowRate: bigint,
    token1BorrowRate: bigint,
    quoteToken: string,
    quoteTokensPerShare: bigint,
    borrowToken0Reserves: bigint,
    borrowToken1Reserves: bigint
  ] & {
    dexPool: string;
    dexId: bigint;
    fee: bigint;
    lastStoredPrice: bigint;
    centerPrice: bigint;
    token0Utilization: bigint;
    token1Utilization: bigint;
    totalBorrowShares: bigint;
    maxBorrowShares: bigint;
    token0Borrowed: bigint;
    token1Borrowed: bigint;
    sharesBorrowable: bigint;
    token0Borrowable: bigint;
    token1Borrowable: bigint;
    token0PerBorrowShare: bigint;
    token1PerBorrowShare: bigint;
    token0BorrowRate: bigint;
    token1BorrowRate: bigint;
    quoteToken: string;
    quoteTokensPerShare: bigint;
    borrowToken0Reserves: bigint;
    borrowToken1Reserves: bigint;
  };

  export type VaultDataStruct = {
    vault: AddressLike;
    vaultId: BigNumberish;
    vaultType: BigNumberish;
    isSmartColl: boolean;
    isSmartDebt: boolean;
    supplyToken0: AddressLike;
    supplyToken1: AddressLike;
    borrowToken0: AddressLike;
    borrowToken1: AddressLike;
    supplyToken0Decimals: BigNumberish;
    supplyToken1Decimals: BigNumberish;
    borrowToken0Decimals: BigNumberish;
    borrowToken1Decimals: BigNumberish;
    collateralFactor: BigNumberish;
    liquidationThreshold: BigNumberish;
    liquidationMaxLimit: BigNumberish;
    withdrawalGap: BigNumberish;
    liquidationPenalty: BigNumberish;
    borrowFee: BigNumberish;
    oracle: AddressLike;
    oraclePriceOperate: BigNumberish;
    oraclePriceLiquidate: BigNumberish;
    vaultSupplyExchangePrice: BigNumberish;
    vaultBorrowExchangePrice: BigNumberish;
    supplyRateVault: BigNumberish;
    borrowRateVault: BigNumberish;
    rewardsOrFeeRateSupply: BigNumberish;
    rewardsOrFeeRateBorrow: BigNumberish;
    totalPositions: BigNumberish;
    totalSupplyVault: BigNumberish;
    totalBorrowVault: BigNumberish;
    withdrawalLimit: BigNumberish;
    withdrawableUntilLimit: BigNumberish;
    withdrawable: BigNumberish;
    baseWithdrawalLimit: BigNumberish;
    withdrawExpandPercent: BigNumberish;
    withdrawExpandDuration: BigNumberish;
    borrowLimit: BigNumberish;
    borrowableUntilLimit: BigNumberish;
    borrowable: BigNumberish;
    borrowLimitUtilization: BigNumberish;
    maxBorrowLimit: BigNumberish;
    borrowExpandPercent: BigNumberish;
    borrowExpandDuration: BigNumberish;
    baseBorrowLimit: BigNumberish;
    minimumBorrowing: BigNumberish;
    dexSupplyData: FluidView.DexSupplyDataStruct;
    dexBorrowData: FluidView.DexBorrowDataStruct;
  };

  export type VaultDataStructOutput = [
    vault: string,
    vaultId: bigint,
    vaultType: bigint,
    isSmartColl: boolean,
    isSmartDebt: boolean,
    supplyToken0: string,
    supplyToken1: string,
    borrowToken0: string,
    borrowToken1: string,
    supplyToken0Decimals: bigint,
    supplyToken1Decimals: bigint,
    borrowToken0Decimals: bigint,
    borrowToken1Decimals: bigint,
    collateralFactor: bigint,
    liquidationThreshold: bigint,
    liquidationMaxLimit: bigint,
    withdrawalGap: bigint,
    liquidationPenalty: bigint,
    borrowFee: bigint,
    oracle: string,
    oraclePriceOperate: bigint,
    oraclePriceLiquidate: bigint,
    vaultSupplyExchangePrice: bigint,
    vaultBorrowExchangePrice: bigint,
    supplyRateVault: bigint,
    borrowRateVault: bigint,
    rewardsOrFeeRateSupply: bigint,
    rewardsOrFeeRateBorrow: bigint,
    totalPositions: bigint,
    totalSupplyVault: bigint,
    totalBorrowVault: bigint,
    withdrawalLimit: bigint,
    withdrawableUntilLimit: bigint,
    withdrawable: bigint,
    baseWithdrawalLimit: bigint,
    withdrawExpandPercent: bigint,
    withdrawExpandDuration: bigint,
    borrowLimit: bigint,
    borrowableUntilLimit: bigint,
    borrowable: bigint,
    borrowLimitUtilization: bigint,
    maxBorrowLimit: bigint,
    borrowExpandPercent: bigint,
    borrowExpandDuration: bigint,
    baseBorrowLimit: bigint,
    minimumBorrowing: bigint,
    dexSupplyData: FluidView.DexSupplyDataStructOutput,
    dexBorrowData: FluidView.DexBorrowDataStructOutput
  ] & {
    vault: string;
    vaultId: bigint;
    vaultType: bigint;
    isSmartColl: boolean;
    isSmartDebt: boolean;
    supplyToken0: string;
    supplyToken1: string;
    borrowToken0: string;
    borrowToken1: string;
    supplyToken0Decimals: bigint;
    supplyToken1Decimals: bigint;
    borrowToken0Decimals: bigint;
    borrowToken1Decimals: bigint;
    collateralFactor: bigint;
    liquidationThreshold: bigint;
    liquidationMaxLimit: bigint;
    withdrawalGap: bigint;
    liquidationPenalty: bigint;
    borrowFee: bigint;
    oracle: string;
    oraclePriceOperate: bigint;
    oraclePriceLiquidate: bigint;
    vaultSupplyExchangePrice: bigint;
    vaultBorrowExchangePrice: bigint;
    supplyRateVault: bigint;
    borrowRateVault: bigint;
    rewardsOrFeeRateSupply: bigint;
    rewardsOrFeeRateBorrow: bigint;
    totalPositions: bigint;
    totalSupplyVault: bigint;
    totalBorrowVault: bigint;
    withdrawalLimit: bigint;
    withdrawableUntilLimit: bigint;
    withdrawable: bigint;
    baseWithdrawalLimit: bigint;
    withdrawExpandPercent: bigint;
    withdrawExpandDuration: bigint;
    borrowLimit: bigint;
    borrowableUntilLimit: bigint;
    borrowable: bigint;
    borrowLimitUtilization: bigint;
    maxBorrowLimit: bigint;
    borrowExpandPercent: bigint;
    borrowExpandDuration: bigint;
    baseBorrowLimit: bigint;
    minimumBorrowing: bigint;
    dexSupplyData: FluidView.DexSupplyDataStructOutput;
    dexBorrowData: FluidView.DexBorrowDataStructOutput;
  };

  export type NftWithVaultStruct = {
    nftId: BigNumberish;
    vaultId: BigNumberish;
    vaultAddr: AddressLike;
  };

  export type NftWithVaultStructOutput = [
    nftId: bigint,
    vaultId: bigint,
    vaultAddr: string
  ] & { nftId: bigint; vaultId: bigint; vaultAddr: string };
}

export interface FluidViewInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "estimateBorrow"
      | "estimateDeposit"
      | "estimateDexPositionCollateralInOneToken"
      | "estimateDexPositionDebtInOneToken"
      | "estimatePayback"
      | "estimateWithdraw"
      | "getAllFTokens"
      | "getAllFTokensData"
      | "getAllUserEarnPositionsWithFTokens"
      | "getDexShareRates"
      | "getFTokenData"
      | "getPositionByNftId"
      | "getRatio"
      | "getUserEarnPosition"
      | "getUserEarnPositionWithFToken"
      | "getUserNftIds"
      | "getUserNftIdsWithVaultIds"
      | "getUserPositions"
      | "getVaultData"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "estimateBorrow",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateDeposit",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateDexPositionCollateralInOneToken",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateDexPositionDebtInOneToken",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimatePayback",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateWithdraw",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllFTokens",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAllFTokensData",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAllUserEarnPositionsWithFTokens",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getDexShareRates",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getFTokenData",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getPositionByNftId",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getRatio",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserEarnPosition",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserEarnPositionWithFToken",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserNftIds",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserNftIdsWithVaultIds",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserPositions",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultData",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "estimateBorrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateDexPositionCollateralInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateDexPositionDebtInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimatePayback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllFTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllFTokensData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllUserEarnPositionsWithFTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDexShareRates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFTokenData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPositionByNftId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getRatio", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getUserEarnPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserEarnPositionWithFToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserNftIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserNftIdsWithVaultIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserPositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultData",
    data: BytesLike
  ): Result;
}

export interface FluidView extends BaseContract {
  connect(runner?: ContractRunner | null): FluidView;
  waitForDeployment(): Promise<this>;

  interface: FluidViewInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  estimateBorrow: TypedContractMethod<
    [
      _vault: AddressLike,
      _token0Amount: BigNumberish,
      _token1Amount: BigNumberish,
      _maxSharesAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  estimateDeposit: TypedContractMethod<
    [
      _vault: AddressLike,
      _token0Amount: BigNumberish,
      _token1Amount: BigNumberish,
      _minSharesAmount: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  estimateDexPositionCollateralInOneToken: TypedContractMethod<
    [
      _nftId: BigNumberish,
      _minToken0AmountToAccept: BigNumberish,
      _minToken1AmountToAccept: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  estimateDexPositionDebtInOneToken: TypedContractMethod<
    [
      _nftId: BigNumberish,
      _maxToken0AmountToPayback: BigNumberish,
      _maxToken1AmountToPayback: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  estimatePayback: TypedContractMethod<
    [
      _vault: AddressLike,
      _token0Amount: BigNumberish,
      _token1Amount: BigNumberish,
      _minSharesAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  estimateWithdraw: TypedContractMethod<
    [
      _vault: AddressLike,
      _token0Amount: BigNumberish,
      _token1Amount: BigNumberish,
      _maxSharesAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  getAllFTokens: TypedContractMethod<[], [string[]], "view">;

  getAllFTokensData: TypedContractMethod<
    [],
    [FluidView.FTokenDataStructOutput[]],
    "view"
  >;

  getAllUserEarnPositionsWithFTokens: TypedContractMethod<
    [_user: AddressLike],
    [
      [
        FluidView.UserEarnPositionStructOutput[],
        FluidView.FTokenDataStructOutput[]
      ] & {
        userPositions: FluidView.UserEarnPositionStructOutput[];
        fTokensData: FluidView.FTokenDataStructOutput[];
      }
    ],
    "view"
  >;

  getDexShareRates: TypedContractMethod<
    [_vault: AddressLike],
    [
      [bigint, bigint, bigint, bigint] & {
        token0PerSupplyShare: bigint;
        token1PerSupplyShare: bigint;
        token0PerBorrowShare: bigint;
        token1PerBorrowShare: bigint;
      }
    ],
    "nonpayable"
  >;

  getFTokenData: TypedContractMethod<
    [_fToken: AddressLike],
    [FluidView.FTokenDataStructOutput],
    "view"
  >;

  getPositionByNftId: TypedContractMethod<
    [_nftId: BigNumberish],
    [
      [FluidView.UserPositionStructOutput, FluidView.VaultDataStructOutput] & {
        position: FluidView.UserPositionStructOutput;
        vault: FluidView.VaultDataStructOutput;
      }
    ],
    "nonpayable"
  >;

  getRatio: TypedContractMethod<[_nftId: BigNumberish], [bigint], "view">;

  getUserEarnPosition: TypedContractMethod<
    [_fToken: AddressLike, _user: AddressLike],
    [FluidView.UserEarnPositionStructOutput],
    "view"
  >;

  getUserEarnPositionWithFToken: TypedContractMethod<
    [_fToken: AddressLike, _user: AddressLike],
    [
      [
        FluidView.UserEarnPositionStructOutput,
        FluidView.FTokenDataStructOutput
      ] & {
        userPosition: FluidView.UserEarnPositionStructOutput;
        fTokenData: FluidView.FTokenDataStructOutput;
      }
    ],
    "view"
  >;

  getUserNftIds: TypedContractMethod<[_user: AddressLike], [bigint[]], "view">;

  getUserNftIdsWithVaultIds: TypedContractMethod<
    [_user: AddressLike],
    [FluidView.NftWithVaultStructOutput[]],
    "view"
  >;

  getUserPositions: TypedContractMethod<
    [_user: AddressLike],
    [
      [
        FluidView.UserPositionStructOutput[],
        FluidView.VaultDataStructOutput[]
      ] & {
        positions: FluidView.UserPositionStructOutput[];
        vaults: FluidView.VaultDataStructOutput[];
      }
    ],
    "nonpayable"
  >;

  getVaultData: TypedContractMethod<
    [_vault: AddressLike],
    [FluidView.VaultDataStructOutput],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "estimateBorrow"
  ): TypedContractMethod<
    [
      _vault: AddressLike,
      _token0Amount: BigNumberish,
      _token1Amount: BigNumberish,
      _maxSharesAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "estimateDeposit"
  ): TypedContractMethod<
    [
      _vault: AddressLike,
      _token0Amount: BigNumberish,
      _token1Amount: BigNumberish,
      _minSharesAmount: BigNumberish
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "estimateDexPositionCollateralInOneToken"
  ): TypedContractMethod<
    [
      _nftId: BigNumberish,
      _minToken0AmountToAccept: BigNumberish,
      _minToken1AmountToAccept: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "estimateDexPositionDebtInOneToken"
  ): TypedContractMethod<
    [
      _nftId: BigNumberish,
      _maxToken0AmountToPayback: BigNumberish,
      _maxToken1AmountToPayback: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "estimatePayback"
  ): TypedContractMethod<
    [
      _vault: AddressLike,
      _token0Amount: BigNumberish,
      _token1Amount: BigNumberish,
      _minSharesAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "estimateWithdraw"
  ): TypedContractMethod<
    [
      _vault: AddressLike,
      _token0Amount: BigNumberish,
      _token1Amount: BigNumberish,
      _maxSharesAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getAllFTokens"
  ): TypedContractMethod<[], [string[]], "view">;
  getFunction(
    nameOrSignature: "getAllFTokensData"
  ): TypedContractMethod<[], [FluidView.FTokenDataStructOutput[]], "view">;
  getFunction(
    nameOrSignature: "getAllUserEarnPositionsWithFTokens"
  ): TypedContractMethod<
    [_user: AddressLike],
    [
      [
        FluidView.UserEarnPositionStructOutput[],
        FluidView.FTokenDataStructOutput[]
      ] & {
        userPositions: FluidView.UserEarnPositionStructOutput[];
        fTokensData: FluidView.FTokenDataStructOutput[];
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getDexShareRates"
  ): TypedContractMethod<
    [_vault: AddressLike],
    [
      [bigint, bigint, bigint, bigint] & {
        token0PerSupplyShare: bigint;
        token1PerSupplyShare: bigint;
        token0PerBorrowShare: bigint;
        token1PerBorrowShare: bigint;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getFTokenData"
  ): TypedContractMethod<
    [_fToken: AddressLike],
    [FluidView.FTokenDataStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPositionByNftId"
  ): TypedContractMethod<
    [_nftId: BigNumberish],
    [
      [FluidView.UserPositionStructOutput, FluidView.VaultDataStructOutput] & {
        position: FluidView.UserPositionStructOutput;
        vault: FluidView.VaultDataStructOutput;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getRatio"
  ): TypedContractMethod<[_nftId: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "getUserEarnPosition"
  ): TypedContractMethod<
    [_fToken: AddressLike, _user: AddressLike],
    [FluidView.UserEarnPositionStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getUserEarnPositionWithFToken"
  ): TypedContractMethod<
    [_fToken: AddressLike, _user: AddressLike],
    [
      [
        FluidView.UserEarnPositionStructOutput,
        FluidView.FTokenDataStructOutput
      ] & {
        userPosition: FluidView.UserEarnPositionStructOutput;
        fTokenData: FluidView.FTokenDataStructOutput;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getUserNftIds"
  ): TypedContractMethod<[_user: AddressLike], [bigint[]], "view">;
  getFunction(
    nameOrSignature: "getUserNftIdsWithVaultIds"
  ): TypedContractMethod<
    [_user: AddressLike],
    [FluidView.NftWithVaultStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getUserPositions"
  ): TypedContractMethod<
    [_user: AddressLike],
    [
      [
        FluidView.UserPositionStructOutput[],
        FluidView.VaultDataStructOutput[]
      ] & {
        positions: FluidView.UserPositionStructOutput[];
        vaults: FluidView.VaultDataStructOutput[];
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getVaultData"
  ): TypedContractMethod<
    [_vault: AddressLike],
    [FluidView.VaultDataStructOutput],
    "nonpayable"
  >;

  filters: {};
}
