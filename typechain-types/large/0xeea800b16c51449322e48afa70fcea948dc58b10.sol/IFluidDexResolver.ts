/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace IFluidDexT1 {
  export type ImplementationsStruct = {
    shift: PromiseOrValue<string>;
    admin: PromiseOrValue<string>;
    colOperations: PromiseOrValue<string>;
    debtOperations: PromiseOrValue<string>;
    perfectOperationsAndOracle: PromiseOrValue<string>;
  };

  export type ImplementationsStructOutput = [
    string,
    string,
    string,
    string,
    string
  ] & {
    shift: string;
    admin: string;
    colOperations: string;
    debtOperations: string;
    perfectOperationsAndOracle: string;
  };

  export type ConstantViewsStruct = {
    dexId: PromiseOrValue<BigNumberish>;
    liquidity: PromiseOrValue<string>;
    factory: PromiseOrValue<string>;
    implementations: IFluidDexT1.ImplementationsStruct;
    deployerContract: PromiseOrValue<string>;
    token0: PromiseOrValue<string>;
    token1: PromiseOrValue<string>;
    supplyToken0Slot: PromiseOrValue<BytesLike>;
    borrowToken0Slot: PromiseOrValue<BytesLike>;
    supplyToken1Slot: PromiseOrValue<BytesLike>;
    borrowToken1Slot: PromiseOrValue<BytesLike>;
    exchangePriceToken0Slot: PromiseOrValue<BytesLike>;
    exchangePriceToken1Slot: PromiseOrValue<BytesLike>;
    oracleMapping: PromiseOrValue<BigNumberish>;
  };

  export type ConstantViewsStructOutput = [
    BigNumber,
    string,
    string,
    IFluidDexT1.ImplementationsStructOutput,
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber
  ] & {
    dexId: BigNumber;
    liquidity: string;
    factory: string;
    implementations: IFluidDexT1.ImplementationsStructOutput;
    deployerContract: string;
    token0: string;
    token1: string;
    supplyToken0Slot: string;
    borrowToken0Slot: string;
    supplyToken1Slot: string;
    borrowToken1Slot: string;
    exchangePriceToken0Slot: string;
    exchangePriceToken1Slot: string;
    oracleMapping: BigNumber;
  };

  export type ConstantViews2Struct = {
    token0NumeratorPrecision: PromiseOrValue<BigNumberish>;
    token0DenominatorPrecision: PromiseOrValue<BigNumberish>;
    token1NumeratorPrecision: PromiseOrValue<BigNumberish>;
    token1DenominatorPrecision: PromiseOrValue<BigNumberish>;
  };

  export type ConstantViews2StructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    token0NumeratorPrecision: BigNumber;
    token0DenominatorPrecision: BigNumber;
    token1NumeratorPrecision: BigNumber;
    token1DenominatorPrecision: BigNumber;
  };

  export type PricesAndExchangePriceStruct = {
    lastStoredPrice: PromiseOrValue<BigNumberish>;
    centerPrice: PromiseOrValue<BigNumberish>;
    upperRange: PromiseOrValue<BigNumberish>;
    lowerRange: PromiseOrValue<BigNumberish>;
    geometricMean: PromiseOrValue<BigNumberish>;
    supplyToken0ExchangePrice: PromiseOrValue<BigNumberish>;
    borrowToken0ExchangePrice: PromiseOrValue<BigNumberish>;
    supplyToken1ExchangePrice: PromiseOrValue<BigNumberish>;
    borrowToken1ExchangePrice: PromiseOrValue<BigNumberish>;
  };

  export type PricesAndExchangePriceStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    lastStoredPrice: BigNumber;
    centerPrice: BigNumber;
    upperRange: BigNumber;
    lowerRange: BigNumber;
    geometricMean: BigNumber;
    supplyToken0ExchangePrice: BigNumber;
    borrowToken0ExchangePrice: BigNumber;
    supplyToken1ExchangePrice: BigNumber;
    borrowToken1ExchangePrice: BigNumber;
  };

  export type CollateralReservesStruct = {
    token0RealReserves: PromiseOrValue<BigNumberish>;
    token1RealReserves: PromiseOrValue<BigNumberish>;
    token0ImaginaryReserves: PromiseOrValue<BigNumberish>;
    token1ImaginaryReserves: PromiseOrValue<BigNumberish>;
  };

  export type CollateralReservesStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    token0RealReserves: BigNumber;
    token1RealReserves: BigNumber;
    token0ImaginaryReserves: BigNumber;
    token1ImaginaryReserves: BigNumber;
  };

  export type DebtReservesStruct = {
    token0Debt: PromiseOrValue<BigNumberish>;
    token1Debt: PromiseOrValue<BigNumberish>;
    token0RealReserves: PromiseOrValue<BigNumberish>;
    token1RealReserves: PromiseOrValue<BigNumberish>;
    token0ImaginaryReserves: PromiseOrValue<BigNumberish>;
    token1ImaginaryReserves: PromiseOrValue<BigNumberish>;
  };

  export type DebtReservesStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    token0Debt: BigNumber;
    token1Debt: BigNumber;
    token0RealReserves: BigNumber;
    token1RealReserves: BigNumber;
    token0ImaginaryReserves: BigNumber;
    token1ImaginaryReserves: BigNumber;
  };
}

export declare namespace IFluidDexResolver {
  export type ConfigsStruct = {
    isSmartCollateralEnabled: PromiseOrValue<boolean>;
    isSmartDebtEnabled: PromiseOrValue<boolean>;
    fee: PromiseOrValue<BigNumberish>;
    revenueCut: PromiseOrValue<BigNumberish>;
    upperRange: PromiseOrValue<BigNumberish>;
    lowerRange: PromiseOrValue<BigNumberish>;
    upperShiftThreshold: PromiseOrValue<BigNumberish>;
    lowerShiftThreshold: PromiseOrValue<BigNumberish>;
    shiftingTime: PromiseOrValue<BigNumberish>;
    centerPriceAddress: PromiseOrValue<string>;
    hookAddress: PromiseOrValue<string>;
    maxCenterPrice: PromiseOrValue<BigNumberish>;
    minCenterPrice: PromiseOrValue<BigNumberish>;
    utilizationLimitToken0: PromiseOrValue<BigNumberish>;
    utilizationLimitToken1: PromiseOrValue<BigNumberish>;
    maxSupplyShares: PromiseOrValue<BigNumberish>;
    maxBorrowShares: PromiseOrValue<BigNumberish>;
  };

  export type ConfigsStructOutput = [
    boolean,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    isSmartCollateralEnabled: boolean;
    isSmartDebtEnabled: boolean;
    fee: BigNumber;
    revenueCut: BigNumber;
    upperRange: BigNumber;
    lowerRange: BigNumber;
    upperShiftThreshold: BigNumber;
    lowerShiftThreshold: BigNumber;
    shiftingTime: BigNumber;
    centerPriceAddress: string;
    hookAddress: string;
    maxCenterPrice: BigNumber;
    minCenterPrice: BigNumber;
    utilizationLimitToken0: BigNumber;
    utilizationLimitToken1: BigNumber;
    maxSupplyShares: BigNumber;
    maxBorrowShares: BigNumber;
  };

  export type ShiftDataStruct = {
    oldUpper: PromiseOrValue<BigNumberish>;
    oldLower: PromiseOrValue<BigNumberish>;
    duration: PromiseOrValue<BigNumberish>;
    startTimestamp: PromiseOrValue<BigNumberish>;
    oldTime: PromiseOrValue<BigNumberish>;
  };

  export type ShiftDataStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    oldUpper: BigNumber;
    oldLower: BigNumber;
    duration: BigNumber;
    startTimestamp: BigNumber;
    oldTime: BigNumber;
  };

  export type CenterPriceShiftStruct = {
    shiftPercentage: PromiseOrValue<BigNumberish>;
    duration: PromiseOrValue<BigNumberish>;
    startTimestamp: PromiseOrValue<BigNumberish>;
  };

  export type CenterPriceShiftStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    shiftPercentage: BigNumber;
    duration: BigNumber;
    startTimestamp: BigNumber;
  };

  export type ShiftChangesStruct = {
    isRangeChangeActive: PromiseOrValue<boolean>;
    isThresholdChangeActive: PromiseOrValue<boolean>;
    isCenterPriceShiftActive: PromiseOrValue<boolean>;
    rangeShift: IFluidDexResolver.ShiftDataStruct;
    thresholdShift: IFluidDexResolver.ShiftDataStruct;
    centerPriceShift: IFluidDexResolver.CenterPriceShiftStruct;
  };

  export type ShiftChangesStructOutput = [
    boolean,
    boolean,
    boolean,
    IFluidDexResolver.ShiftDataStructOutput,
    IFluidDexResolver.ShiftDataStructOutput,
    IFluidDexResolver.CenterPriceShiftStructOutput
  ] & {
    isRangeChangeActive: boolean;
    isThresholdChangeActive: boolean;
    isCenterPriceShiftActive: boolean;
    rangeShift: IFluidDexResolver.ShiftDataStructOutput;
    thresholdShift: IFluidDexResolver.ShiftDataStructOutput;
    centerPriceShift: IFluidDexResolver.CenterPriceShiftStructOutput;
  };

  export type DexStateStruct = {
    lastToLastStoredPrice: PromiseOrValue<BigNumberish>;
    lastStoredPrice: PromiseOrValue<BigNumberish>;
    centerPrice: PromiseOrValue<BigNumberish>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    lastPricesTimeDiff: PromiseOrValue<BigNumberish>;
    oracleCheckPoint: PromiseOrValue<BigNumberish>;
    oracleMapping: PromiseOrValue<BigNumberish>;
    totalSupplyShares: PromiseOrValue<BigNumberish>;
    totalBorrowShares: PromiseOrValue<BigNumberish>;
    isSwapAndArbitragePaused: PromiseOrValue<boolean>;
    shifts: IFluidDexResolver.ShiftChangesStruct;
    token0PerSupplyShare: PromiseOrValue<BigNumberish>;
    token1PerSupplyShare: PromiseOrValue<BigNumberish>;
    token0PerBorrowShare: PromiseOrValue<BigNumberish>;
    token1PerBorrowShare: PromiseOrValue<BigNumberish>;
  };

  export type DexStateStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    IFluidDexResolver.ShiftChangesStructOutput,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    lastToLastStoredPrice: BigNumber;
    lastStoredPrice: BigNumber;
    centerPrice: BigNumber;
    lastUpdateTimestamp: BigNumber;
    lastPricesTimeDiff: BigNumber;
    oracleCheckPoint: BigNumber;
    oracleMapping: BigNumber;
    totalSupplyShares: BigNumber;
    totalBorrowShares: BigNumber;
    isSwapAndArbitragePaused: boolean;
    shifts: IFluidDexResolver.ShiftChangesStructOutput;
    token0PerSupplyShare: BigNumber;
    token1PerSupplyShare: BigNumber;
    token0PerBorrowShare: BigNumber;
    token1PerBorrowShare: BigNumber;
  };

  export type SwapLimitsAndAvailabilityStruct = {
    liquiditySupplyToken0: PromiseOrValue<BigNumberish>;
    liquiditySupplyToken1: PromiseOrValue<BigNumberish>;
    liquidityBorrowToken0: PromiseOrValue<BigNumberish>;
    liquidityBorrowToken1: PromiseOrValue<BigNumberish>;
    liquidityWithdrawableToken0: PromiseOrValue<BigNumberish>;
    liquidityWithdrawableToken1: PromiseOrValue<BigNumberish>;
    liquidityBorrowableToken0: PromiseOrValue<BigNumberish>;
    liquidityBorrowableToken1: PromiseOrValue<BigNumberish>;
    utilizationLimitToken0: PromiseOrValue<BigNumberish>;
    utilizationLimitToken1: PromiseOrValue<BigNumberish>;
    withdrawableUntilUtilizationLimitToken0: PromiseOrValue<BigNumberish>;
    withdrawableUntilUtilizationLimitToken1: PromiseOrValue<BigNumberish>;
    borrowableUntilUtilizationLimitToken0: PromiseOrValue<BigNumberish>;
    borrowableUntilUtilizationLimitToken1: PromiseOrValue<BigNumberish>;
    liquidityUserSupplyDataToken0: IFluidLiquidityResolverStructs.UserSupplyDataStruct;
    liquidityUserSupplyDataToken1: IFluidLiquidityResolverStructs.UserSupplyDataStruct;
    liquidityUserBorrowDataToken0: IFluidLiquidityResolverStructs.UserBorrowDataStruct;
    liquidityUserBorrowDataToken1: IFluidLiquidityResolverStructs.UserBorrowDataStruct;
    liquidityTokenData0: IFluidLiquidityResolverStructs.OverallTokenDataStruct;
    liquidityTokenData1: IFluidLiquidityResolverStructs.OverallTokenDataStruct;
  };

  export type SwapLimitsAndAvailabilityStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    IFluidLiquidityResolverStructs.UserSupplyDataStructOutput,
    IFluidLiquidityResolverStructs.UserSupplyDataStructOutput,
    IFluidLiquidityResolverStructs.UserBorrowDataStructOutput,
    IFluidLiquidityResolverStructs.UserBorrowDataStructOutput,
    IFluidLiquidityResolverStructs.OverallTokenDataStructOutput,
    IFluidLiquidityResolverStructs.OverallTokenDataStructOutput
  ] & {
    liquiditySupplyToken0: BigNumber;
    liquiditySupplyToken1: BigNumber;
    liquidityBorrowToken0: BigNumber;
    liquidityBorrowToken1: BigNumber;
    liquidityWithdrawableToken0: BigNumber;
    liquidityWithdrawableToken1: BigNumber;
    liquidityBorrowableToken0: BigNumber;
    liquidityBorrowableToken1: BigNumber;
    utilizationLimitToken0: BigNumber;
    utilizationLimitToken1: BigNumber;
    withdrawableUntilUtilizationLimitToken0: BigNumber;
    withdrawableUntilUtilizationLimitToken1: BigNumber;
    borrowableUntilUtilizationLimitToken0: BigNumber;
    borrowableUntilUtilizationLimitToken1: BigNumber;
    liquidityUserSupplyDataToken0: IFluidLiquidityResolverStructs.UserSupplyDataStructOutput;
    liquidityUserSupplyDataToken1: IFluidLiquidityResolverStructs.UserSupplyDataStructOutput;
    liquidityUserBorrowDataToken0: IFluidLiquidityResolverStructs.UserBorrowDataStructOutput;
    liquidityUserBorrowDataToken1: IFluidLiquidityResolverStructs.UserBorrowDataStructOutput;
    liquidityTokenData0: IFluidLiquidityResolverStructs.OverallTokenDataStructOutput;
    liquidityTokenData1: IFluidLiquidityResolverStructs.OverallTokenDataStructOutput;
  };

  export type DexEntireDataStruct = {
    dex: PromiseOrValue<string>;
    constantViews: IFluidDexT1.ConstantViewsStruct;
    constantViews2: IFluidDexT1.ConstantViews2Struct;
    configs: IFluidDexResolver.ConfigsStruct;
    pex: IFluidDexT1.PricesAndExchangePriceStruct;
    colReserves: IFluidDexT1.CollateralReservesStruct;
    debtReserves: IFluidDexT1.DebtReservesStruct;
    dexState: IFluidDexResolver.DexStateStruct;
    limitsAndAvailability: IFluidDexResolver.SwapLimitsAndAvailabilityStruct;
  };

  export type DexEntireDataStructOutput = [
    string,
    IFluidDexT1.ConstantViewsStructOutput,
    IFluidDexT1.ConstantViews2StructOutput,
    IFluidDexResolver.ConfigsStructOutput,
    IFluidDexT1.PricesAndExchangePriceStructOutput,
    IFluidDexT1.CollateralReservesStructOutput,
    IFluidDexT1.DebtReservesStructOutput,
    IFluidDexResolver.DexStateStructOutput,
    IFluidDexResolver.SwapLimitsAndAvailabilityStructOutput
  ] & {
    dex: string;
    constantViews: IFluidDexT1.ConstantViewsStructOutput;
    constantViews2: IFluidDexT1.ConstantViews2StructOutput;
    configs: IFluidDexResolver.ConfigsStructOutput;
    pex: IFluidDexT1.PricesAndExchangePriceStructOutput;
    colReserves: IFluidDexT1.CollateralReservesStructOutput;
    debtReserves: IFluidDexT1.DebtReservesStructOutput;
    dexState: IFluidDexResolver.DexStateStructOutput;
    limitsAndAvailability: IFluidDexResolver.SwapLimitsAndAvailabilityStructOutput;
  };
}

export declare namespace IFluidLiquidityResolverStructs {
  export type UserSupplyDataStruct = {
    modeWithInterest: PromiseOrValue<boolean>;
    supply: PromiseOrValue<BigNumberish>;
    withdrawalLimit: PromiseOrValue<BigNumberish>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    expandPercent: PromiseOrValue<BigNumberish>;
    expandDuration: PromiseOrValue<BigNumberish>;
    baseWithdrawalLimit: PromiseOrValue<BigNumberish>;
    withdrawableUntilLimit: PromiseOrValue<BigNumberish>;
    withdrawable: PromiseOrValue<BigNumberish>;
  };

  export type UserSupplyDataStructOutput = [
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    modeWithInterest: boolean;
    supply: BigNumber;
    withdrawalLimit: BigNumber;
    lastUpdateTimestamp: BigNumber;
    expandPercent: BigNumber;
    expandDuration: BigNumber;
    baseWithdrawalLimit: BigNumber;
    withdrawableUntilLimit: BigNumber;
    withdrawable: BigNumber;
  };

  export type UserBorrowDataStruct = {
    modeWithInterest: PromiseOrValue<boolean>;
    borrow: PromiseOrValue<BigNumberish>;
    borrowLimit: PromiseOrValue<BigNumberish>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    expandPercent: PromiseOrValue<BigNumberish>;
    expandDuration: PromiseOrValue<BigNumberish>;
    baseBorrowLimit: PromiseOrValue<BigNumberish>;
    maxBorrowLimit: PromiseOrValue<BigNumberish>;
    borrowableUntilLimit: PromiseOrValue<BigNumberish>;
    borrowable: PromiseOrValue<BigNumberish>;
    borrowLimitUtilization: PromiseOrValue<BigNumberish>;
  };

  export type UserBorrowDataStructOutput = [
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    modeWithInterest: boolean;
    borrow: BigNumber;
    borrowLimit: BigNumber;
    lastUpdateTimestamp: BigNumber;
    expandPercent: BigNumber;
    expandDuration: BigNumber;
    baseBorrowLimit: BigNumber;
    maxBorrowLimit: BigNumber;
    borrowableUntilLimit: BigNumber;
    borrowable: BigNumber;
    borrowLimitUtilization: BigNumber;
  };

  export type RateDataV1ParamsStruct = {
    token: PromiseOrValue<string>;
    kink: PromiseOrValue<BigNumberish>;
    rateAtUtilizationZero: PromiseOrValue<BigNumberish>;
    rateAtUtilizationKink: PromiseOrValue<BigNumberish>;
    rateAtUtilizationMax: PromiseOrValue<BigNumberish>;
  };

  export type RateDataV1ParamsStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    token: string;
    kink: BigNumber;
    rateAtUtilizationZero: BigNumber;
    rateAtUtilizationKink: BigNumber;
    rateAtUtilizationMax: BigNumber;
  };

  export type RateDataV2ParamsStruct = {
    token: PromiseOrValue<string>;
    kink1: PromiseOrValue<BigNumberish>;
    kink2: PromiseOrValue<BigNumberish>;
    rateAtUtilizationZero: PromiseOrValue<BigNumberish>;
    rateAtUtilizationKink1: PromiseOrValue<BigNumberish>;
    rateAtUtilizationKink2: PromiseOrValue<BigNumberish>;
    rateAtUtilizationMax: PromiseOrValue<BigNumberish>;
  };

  export type RateDataV2ParamsStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    token: string;
    kink1: BigNumber;
    kink2: BigNumber;
    rateAtUtilizationZero: BigNumber;
    rateAtUtilizationKink1: BigNumber;
    rateAtUtilizationKink2: BigNumber;
    rateAtUtilizationMax: BigNumber;
  };

  export type RateDataStruct = {
    version: PromiseOrValue<BigNumberish>;
    rateDataV1: IFluidLiquidityResolverStructs.RateDataV1ParamsStruct;
    rateDataV2: IFluidLiquidityResolverStructs.RateDataV2ParamsStruct;
  };

  export type RateDataStructOutput = [
    BigNumber,
    IFluidLiquidityResolverStructs.RateDataV1ParamsStructOutput,
    IFluidLiquidityResolverStructs.RateDataV2ParamsStructOutput
  ] & {
    version: BigNumber;
    rateDataV1: IFluidLiquidityResolverStructs.RateDataV1ParamsStructOutput;
    rateDataV2: IFluidLiquidityResolverStructs.RateDataV2ParamsStructOutput;
  };

  export type OverallTokenDataStruct = {
    borrowRate: PromiseOrValue<BigNumberish>;
    supplyRate: PromiseOrValue<BigNumberish>;
    fee: PromiseOrValue<BigNumberish>;
    lastStoredUtilization: PromiseOrValue<BigNumberish>;
    storageUpdateThreshold: PromiseOrValue<BigNumberish>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    supplyExchangePrice: PromiseOrValue<BigNumberish>;
    borrowExchangePrice: PromiseOrValue<BigNumberish>;
    supplyRawInterest: PromiseOrValue<BigNumberish>;
    supplyInterestFree: PromiseOrValue<BigNumberish>;
    borrowRawInterest: PromiseOrValue<BigNumberish>;
    borrowInterestFree: PromiseOrValue<BigNumberish>;
    totalSupply: PromiseOrValue<BigNumberish>;
    totalBorrow: PromiseOrValue<BigNumberish>;
    revenue: PromiseOrValue<BigNumberish>;
    maxUtilization: PromiseOrValue<BigNumberish>;
    rateData: IFluidLiquidityResolverStructs.RateDataStruct;
  };

  export type OverallTokenDataStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    IFluidLiquidityResolverStructs.RateDataStructOutput
  ] & {
    borrowRate: BigNumber;
    supplyRate: BigNumber;
    fee: BigNumber;
    lastStoredUtilization: BigNumber;
    storageUpdateThreshold: BigNumber;
    lastUpdateTimestamp: BigNumber;
    supplyExchangePrice: BigNumber;
    borrowExchangePrice: BigNumber;
    supplyRawInterest: BigNumber;
    supplyInterestFree: BigNumber;
    borrowRawInterest: BigNumber;
    borrowInterestFree: BigNumber;
    totalSupply: BigNumber;
    totalBorrow: BigNumber;
    revenue: BigNumber;
    maxUtilization: BigNumber;
    rateData: IFluidLiquidityResolverStructs.RateDataStructOutput;
  };
}

export interface IFluidDexResolverInterface extends utils.Interface {
  functions: {
    "estimateBorrow(address,uint256,uint256,uint256)": FunctionFragment;
    "estimateDeposit(address,uint256,uint256,uint256)": FunctionFragment;
    "estimatePayback(address,uint256,uint256,uint256)": FunctionFragment;
    "estimatePaybackPerfectInOneToken(address,uint256,uint256,uint256)": FunctionFragment;
    "estimateWithdraw(address,uint256,uint256,uint256)": FunctionFragment;
    "estimateWithdrawPerfectInOneToken(address,uint256,uint256,uint256)": FunctionFragment;
    "getDexEntireData(address)": FunctionFragment;
    "getDexState(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "estimateBorrow"
      | "estimateDeposit"
      | "estimatePayback"
      | "estimatePaybackPerfectInOneToken"
      | "estimateWithdraw"
      | "estimateWithdrawPerfectInOneToken"
      | "getDexEntireData"
      | "getDexState"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "estimateBorrow",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateDeposit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimatePayback",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimatePaybackPerfectInOneToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateWithdraw",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateWithdrawPerfectInOneToken",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getDexEntireData",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getDexState",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "estimateBorrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimatePayback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimatePaybackPerfectInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateWithdrawPerfectInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDexEntireData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDexState",
    data: BytesLike
  ): Result;

  events: {};
}

export interface IFluidDexResolver extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IFluidDexResolverInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    estimateBorrow(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimateDeposit(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimatePayback(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimatePaybackPerfectInOneToken(
      dex_: PromiseOrValue<string>,
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0_: PromiseOrValue<BigNumberish>,
      maxToken1_: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimateWithdraw(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimateWithdrawPerfectInOneToken(
      dex_: PromiseOrValue<string>,
      shares_: PromiseOrValue<BigNumberish>,
      minToken0_: PromiseOrValue<BigNumberish>,
      minToken1_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getDexEntireData(
      dex_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getDexState(
      dex_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  estimateBorrow(
    dex_: PromiseOrValue<string>,
    token0Amt_: PromiseOrValue<BigNumberish>,
    token1Amt_: PromiseOrValue<BigNumberish>,
    maxSharesAmt_: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimateDeposit(
    dex_: PromiseOrValue<string>,
    token0Amt_: PromiseOrValue<BigNumberish>,
    token1Amt_: PromiseOrValue<BigNumberish>,
    minSharesAmt_: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimatePayback(
    dex_: PromiseOrValue<string>,
    token0Amt_: PromiseOrValue<BigNumberish>,
    token1Amt_: PromiseOrValue<BigNumberish>,
    minSharesAmt_: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimatePaybackPerfectInOneToken(
    dex_: PromiseOrValue<string>,
    shares_: PromiseOrValue<BigNumberish>,
    maxToken0_: PromiseOrValue<BigNumberish>,
    maxToken1_: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimateWithdraw(
    dex_: PromiseOrValue<string>,
    token0Amt_: PromiseOrValue<BigNumberish>,
    token1Amt_: PromiseOrValue<BigNumberish>,
    maxSharesAmt_: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimateWithdrawPerfectInOneToken(
    dex_: PromiseOrValue<string>,
    shares_: PromiseOrValue<BigNumberish>,
    minToken0_: PromiseOrValue<BigNumberish>,
    minToken1_: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getDexEntireData(
    dex_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getDexState(
    dex_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    estimateBorrow(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimateDeposit(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimatePayback(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimatePaybackPerfectInOneToken(
      dex_: PromiseOrValue<string>,
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0_: PromiseOrValue<BigNumberish>,
      maxToken1_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimateWithdraw(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimateWithdrawPerfectInOneToken(
      dex_: PromiseOrValue<string>,
      shares_: PromiseOrValue<BigNumberish>,
      minToken0_: PromiseOrValue<BigNumberish>,
      minToken1_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDexEntireData(
      dex_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IFluidDexResolver.DexEntireDataStructOutput>;

    getDexState(
      dex_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IFluidDexResolver.DexStateStructOutput>;
  };

  filters: {};

  estimateGas: {
    estimateBorrow(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimateDeposit(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimatePayback(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimatePaybackPerfectInOneToken(
      dex_: PromiseOrValue<string>,
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0_: PromiseOrValue<BigNumberish>,
      maxToken1_: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimateWithdraw(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimateWithdrawPerfectInOneToken(
      dex_: PromiseOrValue<string>,
      shares_: PromiseOrValue<BigNumberish>,
      minToken0_: PromiseOrValue<BigNumberish>,
      minToken1_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getDexEntireData(
      dex_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getDexState(
      dex_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    estimateBorrow(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimateDeposit(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimatePayback(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimatePaybackPerfectInOneToken(
      dex_: PromiseOrValue<string>,
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0_: PromiseOrValue<BigNumberish>,
      maxToken1_: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimateWithdraw(
      dex_: PromiseOrValue<string>,
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimateWithdrawPerfectInOneToken(
      dex_: PromiseOrValue<string>,
      shares_: PromiseOrValue<BigNumberish>,
      minToken0_: PromiseOrValue<BigNumberish>,
      minToken1_: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getDexEntireData(
      dex_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getDexState(
      dex_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
