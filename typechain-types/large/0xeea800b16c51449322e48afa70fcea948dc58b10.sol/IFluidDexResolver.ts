/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export declare namespace IFluidDexT1 {
  export type ImplementationsStruct = {
    shift: AddressLike;
    admin: AddressLike;
    colOperations: AddressLike;
    debtOperations: AddressLike;
    perfectOperationsAndOracle: AddressLike;
  };

  export type ImplementationsStructOutput = [
    shift: string,
    admin: string,
    colOperations: string,
    debtOperations: string,
    perfectOperationsAndOracle: string
  ] & {
    shift: string;
    admin: string;
    colOperations: string;
    debtOperations: string;
    perfectOperationsAndOracle: string;
  };

  export type ConstantViewsStruct = {
    dexId: BigNumberish;
    liquidity: AddressLike;
    factory: AddressLike;
    implementations: IFluidDexT1.ImplementationsStruct;
    deployerContract: AddressLike;
    token0: AddressLike;
    token1: AddressLike;
    supplyToken0Slot: BytesLike;
    borrowToken0Slot: BytesLike;
    supplyToken1Slot: BytesLike;
    borrowToken1Slot: BytesLike;
    exchangePriceToken0Slot: BytesLike;
    exchangePriceToken1Slot: BytesLike;
    oracleMapping: BigNumberish;
  };

  export type ConstantViewsStructOutput = [
    dexId: bigint,
    liquidity: string,
    factory: string,
    implementations: IFluidDexT1.ImplementationsStructOutput,
    deployerContract: string,
    token0: string,
    token1: string,
    supplyToken0Slot: string,
    borrowToken0Slot: string,
    supplyToken1Slot: string,
    borrowToken1Slot: string,
    exchangePriceToken0Slot: string,
    exchangePriceToken1Slot: string,
    oracleMapping: bigint
  ] & {
    dexId: bigint;
    liquidity: string;
    factory: string;
    implementations: IFluidDexT1.ImplementationsStructOutput;
    deployerContract: string;
    token0: string;
    token1: string;
    supplyToken0Slot: string;
    borrowToken0Slot: string;
    supplyToken1Slot: string;
    borrowToken1Slot: string;
    exchangePriceToken0Slot: string;
    exchangePriceToken1Slot: string;
    oracleMapping: bigint;
  };

  export type ConstantViews2Struct = {
    token0NumeratorPrecision: BigNumberish;
    token0DenominatorPrecision: BigNumberish;
    token1NumeratorPrecision: BigNumberish;
    token1DenominatorPrecision: BigNumberish;
  };

  export type ConstantViews2StructOutput = [
    token0NumeratorPrecision: bigint,
    token0DenominatorPrecision: bigint,
    token1NumeratorPrecision: bigint,
    token1DenominatorPrecision: bigint
  ] & {
    token0NumeratorPrecision: bigint;
    token0DenominatorPrecision: bigint;
    token1NumeratorPrecision: bigint;
    token1DenominatorPrecision: bigint;
  };

  export type PricesAndExchangePriceStruct = {
    lastStoredPrice: BigNumberish;
    centerPrice: BigNumberish;
    upperRange: BigNumberish;
    lowerRange: BigNumberish;
    geometricMean: BigNumberish;
    supplyToken0ExchangePrice: BigNumberish;
    borrowToken0ExchangePrice: BigNumberish;
    supplyToken1ExchangePrice: BigNumberish;
    borrowToken1ExchangePrice: BigNumberish;
  };

  export type PricesAndExchangePriceStructOutput = [
    lastStoredPrice: bigint,
    centerPrice: bigint,
    upperRange: bigint,
    lowerRange: bigint,
    geometricMean: bigint,
    supplyToken0ExchangePrice: bigint,
    borrowToken0ExchangePrice: bigint,
    supplyToken1ExchangePrice: bigint,
    borrowToken1ExchangePrice: bigint
  ] & {
    lastStoredPrice: bigint;
    centerPrice: bigint;
    upperRange: bigint;
    lowerRange: bigint;
    geometricMean: bigint;
    supplyToken0ExchangePrice: bigint;
    borrowToken0ExchangePrice: bigint;
    supplyToken1ExchangePrice: bigint;
    borrowToken1ExchangePrice: bigint;
  };

  export type CollateralReservesStruct = {
    token0RealReserves: BigNumberish;
    token1RealReserves: BigNumberish;
    token0ImaginaryReserves: BigNumberish;
    token1ImaginaryReserves: BigNumberish;
  };

  export type CollateralReservesStructOutput = [
    token0RealReserves: bigint,
    token1RealReserves: bigint,
    token0ImaginaryReserves: bigint,
    token1ImaginaryReserves: bigint
  ] & {
    token0RealReserves: bigint;
    token1RealReserves: bigint;
    token0ImaginaryReserves: bigint;
    token1ImaginaryReserves: bigint;
  };

  export type DebtReservesStruct = {
    token0Debt: BigNumberish;
    token1Debt: BigNumberish;
    token0RealReserves: BigNumberish;
    token1RealReserves: BigNumberish;
    token0ImaginaryReserves: BigNumberish;
    token1ImaginaryReserves: BigNumberish;
  };

  export type DebtReservesStructOutput = [
    token0Debt: bigint,
    token1Debt: bigint,
    token0RealReserves: bigint,
    token1RealReserves: bigint,
    token0ImaginaryReserves: bigint,
    token1ImaginaryReserves: bigint
  ] & {
    token0Debt: bigint;
    token1Debt: bigint;
    token0RealReserves: bigint;
    token1RealReserves: bigint;
    token0ImaginaryReserves: bigint;
    token1ImaginaryReserves: bigint;
  };
}

export declare namespace IFluidDexResolver {
  export type ConfigsStruct = {
    isSmartCollateralEnabled: boolean;
    isSmartDebtEnabled: boolean;
    fee: BigNumberish;
    revenueCut: BigNumberish;
    upperRange: BigNumberish;
    lowerRange: BigNumberish;
    upperShiftThreshold: BigNumberish;
    lowerShiftThreshold: BigNumberish;
    shiftingTime: BigNumberish;
    centerPriceAddress: AddressLike;
    hookAddress: AddressLike;
    maxCenterPrice: BigNumberish;
    minCenterPrice: BigNumberish;
    utilizationLimitToken0: BigNumberish;
    utilizationLimitToken1: BigNumberish;
    maxSupplyShares: BigNumberish;
    maxBorrowShares: BigNumberish;
  };

  export type ConfigsStructOutput = [
    isSmartCollateralEnabled: boolean,
    isSmartDebtEnabled: boolean,
    fee: bigint,
    revenueCut: bigint,
    upperRange: bigint,
    lowerRange: bigint,
    upperShiftThreshold: bigint,
    lowerShiftThreshold: bigint,
    shiftingTime: bigint,
    centerPriceAddress: string,
    hookAddress: string,
    maxCenterPrice: bigint,
    minCenterPrice: bigint,
    utilizationLimitToken0: bigint,
    utilizationLimitToken1: bigint,
    maxSupplyShares: bigint,
    maxBorrowShares: bigint
  ] & {
    isSmartCollateralEnabled: boolean;
    isSmartDebtEnabled: boolean;
    fee: bigint;
    revenueCut: bigint;
    upperRange: bigint;
    lowerRange: bigint;
    upperShiftThreshold: bigint;
    lowerShiftThreshold: bigint;
    shiftingTime: bigint;
    centerPriceAddress: string;
    hookAddress: string;
    maxCenterPrice: bigint;
    minCenterPrice: bigint;
    utilizationLimitToken0: bigint;
    utilizationLimitToken1: bigint;
    maxSupplyShares: bigint;
    maxBorrowShares: bigint;
  };

  export type ShiftDataStruct = {
    oldUpper: BigNumberish;
    oldLower: BigNumberish;
    duration: BigNumberish;
    startTimestamp: BigNumberish;
    oldTime: BigNumberish;
  };

  export type ShiftDataStructOutput = [
    oldUpper: bigint,
    oldLower: bigint,
    duration: bigint,
    startTimestamp: bigint,
    oldTime: bigint
  ] & {
    oldUpper: bigint;
    oldLower: bigint;
    duration: bigint;
    startTimestamp: bigint;
    oldTime: bigint;
  };

  export type CenterPriceShiftStruct = {
    shiftPercentage: BigNumberish;
    duration: BigNumberish;
    startTimestamp: BigNumberish;
  };

  export type CenterPriceShiftStructOutput = [
    shiftPercentage: bigint,
    duration: bigint,
    startTimestamp: bigint
  ] & { shiftPercentage: bigint; duration: bigint; startTimestamp: bigint };

  export type ShiftChangesStruct = {
    isRangeChangeActive: boolean;
    isThresholdChangeActive: boolean;
    isCenterPriceShiftActive: boolean;
    rangeShift: IFluidDexResolver.ShiftDataStruct;
    thresholdShift: IFluidDexResolver.ShiftDataStruct;
    centerPriceShift: IFluidDexResolver.CenterPriceShiftStruct;
  };

  export type ShiftChangesStructOutput = [
    isRangeChangeActive: boolean,
    isThresholdChangeActive: boolean,
    isCenterPriceShiftActive: boolean,
    rangeShift: IFluidDexResolver.ShiftDataStructOutput,
    thresholdShift: IFluidDexResolver.ShiftDataStructOutput,
    centerPriceShift: IFluidDexResolver.CenterPriceShiftStructOutput
  ] & {
    isRangeChangeActive: boolean;
    isThresholdChangeActive: boolean;
    isCenterPriceShiftActive: boolean;
    rangeShift: IFluidDexResolver.ShiftDataStructOutput;
    thresholdShift: IFluidDexResolver.ShiftDataStructOutput;
    centerPriceShift: IFluidDexResolver.CenterPriceShiftStructOutput;
  };

  export type DexStateStruct = {
    lastToLastStoredPrice: BigNumberish;
    lastStoredPrice: BigNumberish;
    centerPrice: BigNumberish;
    lastUpdateTimestamp: BigNumberish;
    lastPricesTimeDiff: BigNumberish;
    oracleCheckPoint: BigNumberish;
    oracleMapping: BigNumberish;
    totalSupplyShares: BigNumberish;
    totalBorrowShares: BigNumberish;
    isSwapAndArbitragePaused: boolean;
    shifts: IFluidDexResolver.ShiftChangesStruct;
    token0PerSupplyShare: BigNumberish;
    token1PerSupplyShare: BigNumberish;
    token0PerBorrowShare: BigNumberish;
    token1PerBorrowShare: BigNumberish;
  };

  export type DexStateStructOutput = [
    lastToLastStoredPrice: bigint,
    lastStoredPrice: bigint,
    centerPrice: bigint,
    lastUpdateTimestamp: bigint,
    lastPricesTimeDiff: bigint,
    oracleCheckPoint: bigint,
    oracleMapping: bigint,
    totalSupplyShares: bigint,
    totalBorrowShares: bigint,
    isSwapAndArbitragePaused: boolean,
    shifts: IFluidDexResolver.ShiftChangesStructOutput,
    token0PerSupplyShare: bigint,
    token1PerSupplyShare: bigint,
    token0PerBorrowShare: bigint,
    token1PerBorrowShare: bigint
  ] & {
    lastToLastStoredPrice: bigint;
    lastStoredPrice: bigint;
    centerPrice: bigint;
    lastUpdateTimestamp: bigint;
    lastPricesTimeDiff: bigint;
    oracleCheckPoint: bigint;
    oracleMapping: bigint;
    totalSupplyShares: bigint;
    totalBorrowShares: bigint;
    isSwapAndArbitragePaused: boolean;
    shifts: IFluidDexResolver.ShiftChangesStructOutput;
    token0PerSupplyShare: bigint;
    token1PerSupplyShare: bigint;
    token0PerBorrowShare: bigint;
    token1PerBorrowShare: bigint;
  };

  export type SwapLimitsAndAvailabilityStruct = {
    liquiditySupplyToken0: BigNumberish;
    liquiditySupplyToken1: BigNumberish;
    liquidityBorrowToken0: BigNumberish;
    liquidityBorrowToken1: BigNumberish;
    liquidityWithdrawableToken0: BigNumberish;
    liquidityWithdrawableToken1: BigNumberish;
    liquidityBorrowableToken0: BigNumberish;
    liquidityBorrowableToken1: BigNumberish;
    utilizationLimitToken0: BigNumberish;
    utilizationLimitToken1: BigNumberish;
    withdrawableUntilUtilizationLimitToken0: BigNumberish;
    withdrawableUntilUtilizationLimitToken1: BigNumberish;
    borrowableUntilUtilizationLimitToken0: BigNumberish;
    borrowableUntilUtilizationLimitToken1: BigNumberish;
    liquidityUserSupplyDataToken0: IFluidLiquidityResolverStructs.UserSupplyDataStruct;
    liquidityUserSupplyDataToken1: IFluidLiquidityResolverStructs.UserSupplyDataStruct;
    liquidityUserBorrowDataToken0: IFluidLiquidityResolverStructs.UserBorrowDataStruct;
    liquidityUserBorrowDataToken1: IFluidLiquidityResolverStructs.UserBorrowDataStruct;
    liquidityTokenData0: IFluidLiquidityResolverStructs.OverallTokenDataStruct;
    liquidityTokenData1: IFluidLiquidityResolverStructs.OverallTokenDataStruct;
  };

  export type SwapLimitsAndAvailabilityStructOutput = [
    liquiditySupplyToken0: bigint,
    liquiditySupplyToken1: bigint,
    liquidityBorrowToken0: bigint,
    liquidityBorrowToken1: bigint,
    liquidityWithdrawableToken0: bigint,
    liquidityWithdrawableToken1: bigint,
    liquidityBorrowableToken0: bigint,
    liquidityBorrowableToken1: bigint,
    utilizationLimitToken0: bigint,
    utilizationLimitToken1: bigint,
    withdrawableUntilUtilizationLimitToken0: bigint,
    withdrawableUntilUtilizationLimitToken1: bigint,
    borrowableUntilUtilizationLimitToken0: bigint,
    borrowableUntilUtilizationLimitToken1: bigint,
    liquidityUserSupplyDataToken0: IFluidLiquidityResolverStructs.UserSupplyDataStructOutput,
    liquidityUserSupplyDataToken1: IFluidLiquidityResolverStructs.UserSupplyDataStructOutput,
    liquidityUserBorrowDataToken0: IFluidLiquidityResolverStructs.UserBorrowDataStructOutput,
    liquidityUserBorrowDataToken1: IFluidLiquidityResolverStructs.UserBorrowDataStructOutput,
    liquidityTokenData0: IFluidLiquidityResolverStructs.OverallTokenDataStructOutput,
    liquidityTokenData1: IFluidLiquidityResolverStructs.OverallTokenDataStructOutput
  ] & {
    liquiditySupplyToken0: bigint;
    liquiditySupplyToken1: bigint;
    liquidityBorrowToken0: bigint;
    liquidityBorrowToken1: bigint;
    liquidityWithdrawableToken0: bigint;
    liquidityWithdrawableToken1: bigint;
    liquidityBorrowableToken0: bigint;
    liquidityBorrowableToken1: bigint;
    utilizationLimitToken0: bigint;
    utilizationLimitToken1: bigint;
    withdrawableUntilUtilizationLimitToken0: bigint;
    withdrawableUntilUtilizationLimitToken1: bigint;
    borrowableUntilUtilizationLimitToken0: bigint;
    borrowableUntilUtilizationLimitToken1: bigint;
    liquidityUserSupplyDataToken0: IFluidLiquidityResolverStructs.UserSupplyDataStructOutput;
    liquidityUserSupplyDataToken1: IFluidLiquidityResolverStructs.UserSupplyDataStructOutput;
    liquidityUserBorrowDataToken0: IFluidLiquidityResolverStructs.UserBorrowDataStructOutput;
    liquidityUserBorrowDataToken1: IFluidLiquidityResolverStructs.UserBorrowDataStructOutput;
    liquidityTokenData0: IFluidLiquidityResolverStructs.OverallTokenDataStructOutput;
    liquidityTokenData1: IFluidLiquidityResolverStructs.OverallTokenDataStructOutput;
  };

  export type DexEntireDataStruct = {
    dex: AddressLike;
    constantViews: IFluidDexT1.ConstantViewsStruct;
    constantViews2: IFluidDexT1.ConstantViews2Struct;
    configs: IFluidDexResolver.ConfigsStruct;
    pex: IFluidDexT1.PricesAndExchangePriceStruct;
    colReserves: IFluidDexT1.CollateralReservesStruct;
    debtReserves: IFluidDexT1.DebtReservesStruct;
    dexState: IFluidDexResolver.DexStateStruct;
    limitsAndAvailability: IFluidDexResolver.SwapLimitsAndAvailabilityStruct;
  };

  export type DexEntireDataStructOutput = [
    dex: string,
    constantViews: IFluidDexT1.ConstantViewsStructOutput,
    constantViews2: IFluidDexT1.ConstantViews2StructOutput,
    configs: IFluidDexResolver.ConfigsStructOutput,
    pex: IFluidDexT1.PricesAndExchangePriceStructOutput,
    colReserves: IFluidDexT1.CollateralReservesStructOutput,
    debtReserves: IFluidDexT1.DebtReservesStructOutput,
    dexState: IFluidDexResolver.DexStateStructOutput,
    limitsAndAvailability: IFluidDexResolver.SwapLimitsAndAvailabilityStructOutput
  ] & {
    dex: string;
    constantViews: IFluidDexT1.ConstantViewsStructOutput;
    constantViews2: IFluidDexT1.ConstantViews2StructOutput;
    configs: IFluidDexResolver.ConfigsStructOutput;
    pex: IFluidDexT1.PricesAndExchangePriceStructOutput;
    colReserves: IFluidDexT1.CollateralReservesStructOutput;
    debtReserves: IFluidDexT1.DebtReservesStructOutput;
    dexState: IFluidDexResolver.DexStateStructOutput;
    limitsAndAvailability: IFluidDexResolver.SwapLimitsAndAvailabilityStructOutput;
  };
}

export declare namespace IFluidLiquidityResolverStructs {
  export type UserSupplyDataStruct = {
    modeWithInterest: boolean;
    supply: BigNumberish;
    withdrawalLimit: BigNumberish;
    lastUpdateTimestamp: BigNumberish;
    expandPercent: BigNumberish;
    expandDuration: BigNumberish;
    baseWithdrawalLimit: BigNumberish;
    withdrawableUntilLimit: BigNumberish;
    withdrawable: BigNumberish;
  };

  export type UserSupplyDataStructOutput = [
    modeWithInterest: boolean,
    supply: bigint,
    withdrawalLimit: bigint,
    lastUpdateTimestamp: bigint,
    expandPercent: bigint,
    expandDuration: bigint,
    baseWithdrawalLimit: bigint,
    withdrawableUntilLimit: bigint,
    withdrawable: bigint
  ] & {
    modeWithInterest: boolean;
    supply: bigint;
    withdrawalLimit: bigint;
    lastUpdateTimestamp: bigint;
    expandPercent: bigint;
    expandDuration: bigint;
    baseWithdrawalLimit: bigint;
    withdrawableUntilLimit: bigint;
    withdrawable: bigint;
  };

  export type UserBorrowDataStruct = {
    modeWithInterest: boolean;
    borrow: BigNumberish;
    borrowLimit: BigNumberish;
    lastUpdateTimestamp: BigNumberish;
    expandPercent: BigNumberish;
    expandDuration: BigNumberish;
    baseBorrowLimit: BigNumberish;
    maxBorrowLimit: BigNumberish;
    borrowableUntilLimit: BigNumberish;
    borrowable: BigNumberish;
    borrowLimitUtilization: BigNumberish;
  };

  export type UserBorrowDataStructOutput = [
    modeWithInterest: boolean,
    borrow: bigint,
    borrowLimit: bigint,
    lastUpdateTimestamp: bigint,
    expandPercent: bigint,
    expandDuration: bigint,
    baseBorrowLimit: bigint,
    maxBorrowLimit: bigint,
    borrowableUntilLimit: bigint,
    borrowable: bigint,
    borrowLimitUtilization: bigint
  ] & {
    modeWithInterest: boolean;
    borrow: bigint;
    borrowLimit: bigint;
    lastUpdateTimestamp: bigint;
    expandPercent: bigint;
    expandDuration: bigint;
    baseBorrowLimit: bigint;
    maxBorrowLimit: bigint;
    borrowableUntilLimit: bigint;
    borrowable: bigint;
    borrowLimitUtilization: bigint;
  };

  export type RateDataV1ParamsStruct = {
    token: AddressLike;
    kink: BigNumberish;
    rateAtUtilizationZero: BigNumberish;
    rateAtUtilizationKink: BigNumberish;
    rateAtUtilizationMax: BigNumberish;
  };

  export type RateDataV1ParamsStructOutput = [
    token: string,
    kink: bigint,
    rateAtUtilizationZero: bigint,
    rateAtUtilizationKink: bigint,
    rateAtUtilizationMax: bigint
  ] & {
    token: string;
    kink: bigint;
    rateAtUtilizationZero: bigint;
    rateAtUtilizationKink: bigint;
    rateAtUtilizationMax: bigint;
  };

  export type RateDataV2ParamsStruct = {
    token: AddressLike;
    kink1: BigNumberish;
    kink2: BigNumberish;
    rateAtUtilizationZero: BigNumberish;
    rateAtUtilizationKink1: BigNumberish;
    rateAtUtilizationKink2: BigNumberish;
    rateAtUtilizationMax: BigNumberish;
  };

  export type RateDataV2ParamsStructOutput = [
    token: string,
    kink1: bigint,
    kink2: bigint,
    rateAtUtilizationZero: bigint,
    rateAtUtilizationKink1: bigint,
    rateAtUtilizationKink2: bigint,
    rateAtUtilizationMax: bigint
  ] & {
    token: string;
    kink1: bigint;
    kink2: bigint;
    rateAtUtilizationZero: bigint;
    rateAtUtilizationKink1: bigint;
    rateAtUtilizationKink2: bigint;
    rateAtUtilizationMax: bigint;
  };

  export type RateDataStruct = {
    version: BigNumberish;
    rateDataV1: IFluidLiquidityResolverStructs.RateDataV1ParamsStruct;
    rateDataV2: IFluidLiquidityResolverStructs.RateDataV2ParamsStruct;
  };

  export type RateDataStructOutput = [
    version: bigint,
    rateDataV1: IFluidLiquidityResolverStructs.RateDataV1ParamsStructOutput,
    rateDataV2: IFluidLiquidityResolverStructs.RateDataV2ParamsStructOutput
  ] & {
    version: bigint;
    rateDataV1: IFluidLiquidityResolverStructs.RateDataV1ParamsStructOutput;
    rateDataV2: IFluidLiquidityResolverStructs.RateDataV2ParamsStructOutput;
  };

  export type OverallTokenDataStruct = {
    borrowRate: BigNumberish;
    supplyRate: BigNumberish;
    fee: BigNumberish;
    lastStoredUtilization: BigNumberish;
    storageUpdateThreshold: BigNumberish;
    lastUpdateTimestamp: BigNumberish;
    supplyExchangePrice: BigNumberish;
    borrowExchangePrice: BigNumberish;
    supplyRawInterest: BigNumberish;
    supplyInterestFree: BigNumberish;
    borrowRawInterest: BigNumberish;
    borrowInterestFree: BigNumberish;
    totalSupply: BigNumberish;
    totalBorrow: BigNumberish;
    revenue: BigNumberish;
    maxUtilization: BigNumberish;
    rateData: IFluidLiquidityResolverStructs.RateDataStruct;
  };

  export type OverallTokenDataStructOutput = [
    borrowRate: bigint,
    supplyRate: bigint,
    fee: bigint,
    lastStoredUtilization: bigint,
    storageUpdateThreshold: bigint,
    lastUpdateTimestamp: bigint,
    supplyExchangePrice: bigint,
    borrowExchangePrice: bigint,
    supplyRawInterest: bigint,
    supplyInterestFree: bigint,
    borrowRawInterest: bigint,
    borrowInterestFree: bigint,
    totalSupply: bigint,
    totalBorrow: bigint,
    revenue: bigint,
    maxUtilization: bigint,
    rateData: IFluidLiquidityResolverStructs.RateDataStructOutput
  ] & {
    borrowRate: bigint;
    supplyRate: bigint;
    fee: bigint;
    lastStoredUtilization: bigint;
    storageUpdateThreshold: bigint;
    lastUpdateTimestamp: bigint;
    supplyExchangePrice: bigint;
    borrowExchangePrice: bigint;
    supplyRawInterest: bigint;
    supplyInterestFree: bigint;
    borrowRawInterest: bigint;
    borrowInterestFree: bigint;
    totalSupply: bigint;
    totalBorrow: bigint;
    revenue: bigint;
    maxUtilization: bigint;
    rateData: IFluidLiquidityResolverStructs.RateDataStructOutput;
  };
}

export interface IFluidDexResolverInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "estimateBorrow"
      | "estimateDeposit"
      | "estimatePayback"
      | "estimatePaybackPerfectInOneToken"
      | "estimateWithdraw"
      | "estimateWithdrawPerfectInOneToken"
      | "getDexEntireData"
      | "getDexState"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "estimateBorrow",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateDeposit",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimatePayback",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimatePaybackPerfectInOneToken",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateWithdraw",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateWithdrawPerfectInOneToken",
    values: [AddressLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getDexEntireData",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getDexState",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "estimateBorrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimatePayback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimatePaybackPerfectInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateWithdrawPerfectInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDexEntireData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDexState",
    data: BytesLike
  ): Result;
}

export interface IFluidDexResolver extends BaseContract {
  connect(runner?: ContractRunner | null): IFluidDexResolver;
  waitForDeployment(): Promise<this>;

  interface: IFluidDexResolverInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  estimateBorrow: TypedContractMethod<
    [
      dex_: AddressLike,
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      maxSharesAmt_: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  estimateDeposit: TypedContractMethod<
    [
      dex_: AddressLike,
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      minSharesAmt_: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  estimatePayback: TypedContractMethod<
    [
      dex_: AddressLike,
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      minSharesAmt_: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  estimatePaybackPerfectInOneToken: TypedContractMethod<
    [
      dex_: AddressLike,
      shares_: BigNumberish,
      maxToken0_: BigNumberish,
      maxToken1_: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  estimateWithdraw: TypedContractMethod<
    [
      dex_: AddressLike,
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      maxSharesAmt_: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  estimateWithdrawPerfectInOneToken: TypedContractMethod<
    [
      dex_: AddressLike,
      shares_: BigNumberish,
      minToken0_: BigNumberish,
      minToken1_: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  getDexEntireData: TypedContractMethod<
    [dex_: AddressLike],
    [IFluidDexResolver.DexEntireDataStructOutput],
    "nonpayable"
  >;

  getDexState: TypedContractMethod<
    [dex_: AddressLike],
    [IFluidDexResolver.DexStateStructOutput],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "estimateBorrow"
  ): TypedContractMethod<
    [
      dex_: AddressLike,
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      maxSharesAmt_: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "estimateDeposit"
  ): TypedContractMethod<
    [
      dex_: AddressLike,
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      minSharesAmt_: BigNumberish
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "estimatePayback"
  ): TypedContractMethod<
    [
      dex_: AddressLike,
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      minSharesAmt_: BigNumberish
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "estimatePaybackPerfectInOneToken"
  ): TypedContractMethod<
    [
      dex_: AddressLike,
      shares_: BigNumberish,
      maxToken0_: BigNumberish,
      maxToken1_: BigNumberish
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "estimateWithdraw"
  ): TypedContractMethod<
    [
      dex_: AddressLike,
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      maxSharesAmt_: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "estimateWithdrawPerfectInOneToken"
  ): TypedContractMethod<
    [
      dex_: AddressLike,
      shares_: BigNumberish,
      minToken0_: BigNumberish,
      minToken1_: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getDexEntireData"
  ): TypedContractMethod<
    [dex_: AddressLike],
    [IFluidDexResolver.DexEntireDataStructOutput],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getDexState"
  ): TypedContractMethod<
    [dex_: AddressLike],
    [IFluidDexResolver.DexStateStructOutput],
    "nonpayable"
  >;

  filters: {};
}
