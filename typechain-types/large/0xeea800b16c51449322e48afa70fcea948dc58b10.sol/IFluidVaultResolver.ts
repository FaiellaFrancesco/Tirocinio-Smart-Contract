/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace IFluidVaultResolver {
  export type TokensStruct = {
    token0: PromiseOrValue<string>;
    token1: PromiseOrValue<string>;
  };

  export type TokensStructOutput = [string, string] & {
    token0: string;
    token1: string;
  };

  export type ConstantViewsStruct = {
    liquidity: PromiseOrValue<string>;
    factory: PromiseOrValue<string>;
    operateImplementation: PromiseOrValue<string>;
    adminImplementation: PromiseOrValue<string>;
    secondaryImplementation: PromiseOrValue<string>;
    deployer: PromiseOrValue<string>;
    supply: PromiseOrValue<string>;
    borrow: PromiseOrValue<string>;
    supplyToken: IFluidVaultResolver.TokensStruct;
    borrowToken: IFluidVaultResolver.TokensStruct;
    vaultId: PromiseOrValue<BigNumberish>;
    vaultType: PromiseOrValue<BigNumberish>;
    supplyExchangePriceSlot: PromiseOrValue<BytesLike>;
    borrowExchangePriceSlot: PromiseOrValue<BytesLike>;
    userSupplySlot: PromiseOrValue<BytesLike>;
    userBorrowSlot: PromiseOrValue<BytesLike>;
  };

  export type ConstantViewsStructOutput = [
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    IFluidVaultResolver.TokensStructOutput,
    IFluidVaultResolver.TokensStructOutput,
    BigNumber,
    BigNumber,
    string,
    string,
    string,
    string
  ] & {
    liquidity: string;
    factory: string;
    operateImplementation: string;
    adminImplementation: string;
    secondaryImplementation: string;
    deployer: string;
    supply: string;
    borrow: string;
    supplyToken: IFluidVaultResolver.TokensStructOutput;
    borrowToken: IFluidVaultResolver.TokensStructOutput;
    vaultId: BigNumber;
    vaultType: BigNumber;
    supplyExchangePriceSlot: string;
    borrowExchangePriceSlot: string;
    userSupplySlot: string;
    userBorrowSlot: string;
  };

  export type ConfigsStruct = {
    supplyRateMagnifier: PromiseOrValue<BigNumberish>;
    borrowRateMagnifier: PromiseOrValue<BigNumberish>;
    collateralFactor: PromiseOrValue<BigNumberish>;
    liquidationThreshold: PromiseOrValue<BigNumberish>;
    liquidationMaxLimit: PromiseOrValue<BigNumberish>;
    withdrawalGap: PromiseOrValue<BigNumberish>;
    liquidationPenalty: PromiseOrValue<BigNumberish>;
    borrowFee: PromiseOrValue<BigNumberish>;
    oracle: PromiseOrValue<string>;
    oraclePriceOperate: PromiseOrValue<BigNumberish>;
    oraclePriceLiquidate: PromiseOrValue<BigNumberish>;
    rebalancer: PromiseOrValue<string>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
  };

  export type ConfigsStructOutput = [
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    string,
    BigNumber,
    BigNumber,
    string,
    BigNumber
  ] & {
    supplyRateMagnifier: number;
    borrowRateMagnifier: number;
    collateralFactor: number;
    liquidationThreshold: number;
    liquidationMaxLimit: number;
    withdrawalGap: number;
    liquidationPenalty: number;
    borrowFee: number;
    oracle: string;
    oraclePriceOperate: BigNumber;
    oraclePriceLiquidate: BigNumber;
    rebalancer: string;
    lastUpdateTimestamp: BigNumber;
  };

  export type ExchangePricesAndRatesStruct = {
    lastStoredLiquiditySupplyExchangePrice: PromiseOrValue<BigNumberish>;
    lastStoredLiquidityBorrowExchangePrice: PromiseOrValue<BigNumberish>;
    lastStoredVaultSupplyExchangePrice: PromiseOrValue<BigNumberish>;
    lastStoredVaultBorrowExchangePrice: PromiseOrValue<BigNumberish>;
    liquiditySupplyExchangePrice: PromiseOrValue<BigNumberish>;
    liquidityBorrowExchangePrice: PromiseOrValue<BigNumberish>;
    vaultSupplyExchangePrice: PromiseOrValue<BigNumberish>;
    vaultBorrowExchangePrice: PromiseOrValue<BigNumberish>;
    supplyRateLiquidity: PromiseOrValue<BigNumberish>;
    borrowRateLiquidity: PromiseOrValue<BigNumberish>;
    supplyRateVault: PromiseOrValue<BigNumberish>;
    borrowRateVault: PromiseOrValue<BigNumberish>;
    rewardsOrFeeRateSupply: PromiseOrValue<BigNumberish>;
    rewardsOrFeeRateBorrow: PromiseOrValue<BigNumberish>;
  };

  export type ExchangePricesAndRatesStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    lastStoredLiquiditySupplyExchangePrice: BigNumber;
    lastStoredLiquidityBorrowExchangePrice: BigNumber;
    lastStoredVaultSupplyExchangePrice: BigNumber;
    lastStoredVaultBorrowExchangePrice: BigNumber;
    liquiditySupplyExchangePrice: BigNumber;
    liquidityBorrowExchangePrice: BigNumber;
    vaultSupplyExchangePrice: BigNumber;
    vaultBorrowExchangePrice: BigNumber;
    supplyRateLiquidity: BigNumber;
    borrowRateLiquidity: BigNumber;
    supplyRateVault: BigNumber;
    borrowRateVault: BigNumber;
    rewardsOrFeeRateSupply: BigNumber;
    rewardsOrFeeRateBorrow: BigNumber;
  };

  export type TotalSupplyAndBorrowStruct = {
    totalSupplyVault: PromiseOrValue<BigNumberish>;
    totalBorrowVault: PromiseOrValue<BigNumberish>;
    totalSupplyLiquidityOrDex: PromiseOrValue<BigNumberish>;
    totalBorrowLiquidityOrDex: PromiseOrValue<BigNumberish>;
    absorbedSupply: PromiseOrValue<BigNumberish>;
    absorbedBorrow: PromiseOrValue<BigNumberish>;
  };

  export type TotalSupplyAndBorrowStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    totalSupplyVault: BigNumber;
    totalBorrowVault: BigNumber;
    totalSupplyLiquidityOrDex: BigNumber;
    totalBorrowLiquidityOrDex: BigNumber;
    absorbedSupply: BigNumber;
    absorbedBorrow: BigNumber;
  };

  export type LimitsAndAvailabilityStruct = {
    withdrawLimit: PromiseOrValue<BigNumberish>;
    withdrawableUntilLimit: PromiseOrValue<BigNumberish>;
    withdrawable: PromiseOrValue<BigNumberish>;
    borrowLimit: PromiseOrValue<BigNumberish>;
    borrowableUntilLimit: PromiseOrValue<BigNumberish>;
    borrowable: PromiseOrValue<BigNumberish>;
    borrowLimitUtilization: PromiseOrValue<BigNumberish>;
    minimumBorrowing: PromiseOrValue<BigNumberish>;
  };

  export type LimitsAndAvailabilityStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    withdrawLimit: BigNumber;
    withdrawableUntilLimit: BigNumber;
    withdrawable: BigNumber;
    borrowLimit: BigNumber;
    borrowableUntilLimit: BigNumber;
    borrowable: BigNumber;
    borrowLimitUtilization: BigNumber;
    minimumBorrowing: BigNumber;
  };

  export type CurrentBranchStateStruct = {
    status: PromiseOrValue<BigNumberish>;
    minimaTick: PromiseOrValue<BigNumberish>;
    debtFactor: PromiseOrValue<BigNumberish>;
    partials: PromiseOrValue<BigNumberish>;
    debtLiquidity: PromiseOrValue<BigNumberish>;
    baseBranchId: PromiseOrValue<BigNumberish>;
    baseBranchMinima: PromiseOrValue<BigNumberish>;
  };

  export type CurrentBranchStateStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    status: BigNumber;
    minimaTick: BigNumber;
    debtFactor: BigNumber;
    partials: BigNumber;
    debtLiquidity: BigNumber;
    baseBranchId: BigNumber;
    baseBranchMinima: BigNumber;
  };

  export type VaultStateStruct = {
    totalPositions: PromiseOrValue<BigNumberish>;
    topTick: PromiseOrValue<BigNumberish>;
    currentBranch: PromiseOrValue<BigNumberish>;
    totalBranch: PromiseOrValue<BigNumberish>;
    totalBorrow: PromiseOrValue<BigNumberish>;
    totalSupply: PromiseOrValue<BigNumberish>;
    currentBranchState: IFluidVaultResolver.CurrentBranchStateStruct;
  };

  export type VaultStateStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    IFluidVaultResolver.CurrentBranchStateStructOutput
  ] & {
    totalPositions: BigNumber;
    topTick: BigNumber;
    currentBranch: BigNumber;
    totalBranch: BigNumber;
    totalBorrow: BigNumber;
    totalSupply: BigNumber;
    currentBranchState: IFluidVaultResolver.CurrentBranchStateStructOutput;
  };

  export type UserSupplyDataStruct = {
    modeWithInterest: PromiseOrValue<boolean>;
    supply: PromiseOrValue<BigNumberish>;
    withdrawalLimit: PromiseOrValue<BigNumberish>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    expandPercent: PromiseOrValue<BigNumberish>;
    expandDuration: PromiseOrValue<BigNumberish>;
    baseWithdrawalLimit: PromiseOrValue<BigNumberish>;
    withdrawableUntilLimit: PromiseOrValue<BigNumberish>;
    withdrawable: PromiseOrValue<BigNumberish>;
  };

  export type UserSupplyDataStructOutput = [
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    modeWithInterest: boolean;
    supply: BigNumber;
    withdrawalLimit: BigNumber;
    lastUpdateTimestamp: BigNumber;
    expandPercent: BigNumber;
    expandDuration: BigNumber;
    baseWithdrawalLimit: BigNumber;
    withdrawableUntilLimit: BigNumber;
    withdrawable: BigNumber;
  };

  export type UserBorrowDataStruct = {
    modeWithInterest: PromiseOrValue<boolean>;
    borrow: PromiseOrValue<BigNumberish>;
    borrowLimit: PromiseOrValue<BigNumberish>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    expandPercent: PromiseOrValue<BigNumberish>;
    expandDuration: PromiseOrValue<BigNumberish>;
    baseBorrowLimit: PromiseOrValue<BigNumberish>;
    maxBorrowLimit: PromiseOrValue<BigNumberish>;
    borrowableUntilLimit: PromiseOrValue<BigNumberish>;
    borrowable: PromiseOrValue<BigNumberish>;
    borrowLimitUtilization: PromiseOrValue<BigNumberish>;
  };

  export type UserBorrowDataStructOutput = [
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    modeWithInterest: boolean;
    borrow: BigNumber;
    borrowLimit: BigNumber;
    lastUpdateTimestamp: BigNumber;
    expandPercent: BigNumber;
    expandDuration: BigNumber;
    baseBorrowLimit: BigNumber;
    maxBorrowLimit: BigNumber;
    borrowableUntilLimit: BigNumber;
    borrowable: BigNumber;
    borrowLimitUtilization: BigNumber;
  };

  export type VaultEntireDataStruct = {
    vault: PromiseOrValue<string>;
    isSmartCol: PromiseOrValue<boolean>;
    isSmartDebt: PromiseOrValue<boolean>;
    constantVariables: IFluidVaultResolver.ConstantViewsStruct;
    configs: IFluidVaultResolver.ConfigsStruct;
    exchangePricesAndRates: IFluidVaultResolver.ExchangePricesAndRatesStruct;
    totalSupplyAndBorrow: IFluidVaultResolver.TotalSupplyAndBorrowStruct;
    limitsAndAvailability: IFluidVaultResolver.LimitsAndAvailabilityStruct;
    vaultState: IFluidVaultResolver.VaultStateStruct;
    liquidityUserSupplyData: IFluidVaultResolver.UserSupplyDataStruct;
    liquidityUserBorrowData: IFluidVaultResolver.UserBorrowDataStruct;
  };

  export type VaultEntireDataStructOutput = [
    string,
    boolean,
    boolean,
    IFluidVaultResolver.ConstantViewsStructOutput,
    IFluidVaultResolver.ConfigsStructOutput,
    IFluidVaultResolver.ExchangePricesAndRatesStructOutput,
    IFluidVaultResolver.TotalSupplyAndBorrowStructOutput,
    IFluidVaultResolver.LimitsAndAvailabilityStructOutput,
    IFluidVaultResolver.VaultStateStructOutput,
    IFluidVaultResolver.UserSupplyDataStructOutput,
    IFluidVaultResolver.UserBorrowDataStructOutput
  ] & {
    vault: string;
    isSmartCol: boolean;
    isSmartDebt: boolean;
    constantVariables: IFluidVaultResolver.ConstantViewsStructOutput;
    configs: IFluidVaultResolver.ConfigsStructOutput;
    exchangePricesAndRates: IFluidVaultResolver.ExchangePricesAndRatesStructOutput;
    totalSupplyAndBorrow: IFluidVaultResolver.TotalSupplyAndBorrowStructOutput;
    limitsAndAvailability: IFluidVaultResolver.LimitsAndAvailabilityStructOutput;
    vaultState: IFluidVaultResolver.VaultStateStructOutput;
    liquidityUserSupplyData: IFluidVaultResolver.UserSupplyDataStructOutput;
    liquidityUserBorrowData: IFluidVaultResolver.UserBorrowDataStructOutput;
  };

  export type UserPositionStruct = {
    nftId: PromiseOrValue<BigNumberish>;
    owner: PromiseOrValue<string>;
    isLiquidated: PromiseOrValue<boolean>;
    isSupplyPosition: PromiseOrValue<boolean>;
    tick: PromiseOrValue<BigNumberish>;
    tickId: PromiseOrValue<BigNumberish>;
    beforeSupply: PromiseOrValue<BigNumberish>;
    beforeBorrow: PromiseOrValue<BigNumberish>;
    beforeDustBorrow: PromiseOrValue<BigNumberish>;
    supply: PromiseOrValue<BigNumberish>;
    borrow: PromiseOrValue<BigNumberish>;
    dustBorrow: PromiseOrValue<BigNumberish>;
  };

  export type UserPositionStructOutput = [
    BigNumber,
    string,
    boolean,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    nftId: BigNumber;
    owner: string;
    isLiquidated: boolean;
    isSupplyPosition: boolean;
    tick: BigNumber;
    tickId: BigNumber;
    beforeSupply: BigNumber;
    beforeBorrow: BigNumber;
    beforeDustBorrow: BigNumber;
    supply: BigNumber;
    borrow: BigNumber;
    dustBorrow: BigNumber;
  };
}

export interface IFluidVaultResolverInterface extends utils.Interface {
  functions: {
    "getAllVaultsAddresses()": FunctionFragment;
    "getVaultAddress(uint256)": FunctionFragment;
    "getVaultEntireData(address)": FunctionFragment;
    "getVaultId(address)": FunctionFragment;
    "positionByNftId(uint256)": FunctionFragment;
    "positionsNftIdOfUser(address)": FunctionFragment;
    "vaultByNftId(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "getAllVaultsAddresses"
      | "getVaultAddress"
      | "getVaultEntireData"
      | "getVaultId"
      | "positionByNftId"
      | "positionsNftIdOfUser"
      | "vaultByNftId"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getAllVaultsAddresses",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultAddress",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultEntireData",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultId",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "positionByNftId",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "positionsNftIdOfUser",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "vaultByNftId",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "getAllVaultsAddresses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultEntireData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getVaultId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "positionByNftId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "positionsNftIdOfUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "vaultByNftId",
    data: BytesLike
  ): Result;

  events: {};
}

export interface IFluidVaultResolver extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IFluidVaultResolverInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    getAllVaultsAddresses(
      overrides?: CallOverrides
    ): Promise<[string[]] & { vaults_: string[] }>;

    getVaultAddress(
      vaultId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { vault_: string }>;

    getVaultEntireData(
      vault_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [IFluidVaultResolver.VaultEntireDataStructOutput] & {
        vaultData_: IFluidVaultResolver.VaultEntireDataStructOutput;
      }
    >;

    getVaultId(
      vault_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { id_: BigNumber }>;

    positionByNftId(
      nftId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        IFluidVaultResolver.UserPositionStructOutput,
        IFluidVaultResolver.VaultEntireDataStructOutput
      ] & {
        userPosition_: IFluidVaultResolver.UserPositionStructOutput;
        vaultData_: IFluidVaultResolver.VaultEntireDataStructOutput;
      }
    >;

    positionsNftIdOfUser(
      user_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { nftIds_: BigNumber[] }>;

    vaultByNftId(
      nftId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { vault_: string }>;
  };

  getAllVaultsAddresses(overrides?: CallOverrides): Promise<string[]>;

  getVaultAddress(
    vaultId_: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getVaultEntireData(
    vault_: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<IFluidVaultResolver.VaultEntireDataStructOutput>;

  getVaultId(
    vault_: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  positionByNftId(
    nftId_: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      IFluidVaultResolver.UserPositionStructOutput,
      IFluidVaultResolver.VaultEntireDataStructOutput
    ] & {
      userPosition_: IFluidVaultResolver.UserPositionStructOutput;
      vaultData_: IFluidVaultResolver.VaultEntireDataStructOutput;
    }
  >;

  positionsNftIdOfUser(
    user_: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  vaultByNftId(
    nftId_: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  callStatic: {
    getAllVaultsAddresses(overrides?: CallOverrides): Promise<string[]>;

    getVaultAddress(
      vaultId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getVaultEntireData(
      vault_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IFluidVaultResolver.VaultEntireDataStructOutput>;

    getVaultId(
      vault_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    positionByNftId(
      nftId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        IFluidVaultResolver.UserPositionStructOutput,
        IFluidVaultResolver.VaultEntireDataStructOutput
      ] & {
        userPosition_: IFluidVaultResolver.UserPositionStructOutput;
        vaultData_: IFluidVaultResolver.VaultEntireDataStructOutput;
      }
    >;

    positionsNftIdOfUser(
      user_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    vaultByNftId(
      nftId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;
  };

  filters: {};

  estimateGas: {
    getAllVaultsAddresses(overrides?: CallOverrides): Promise<BigNumber>;

    getVaultAddress(
      vaultId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVaultEntireData(
      vault_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVaultId(
      vault_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    positionByNftId(
      nftId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    positionsNftIdOfUser(
      user_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    vaultByNftId(
      nftId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    getAllVaultsAddresses(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultAddress(
      vaultId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultEntireData(
      vault_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVaultId(
      vault_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    positionByNftId(
      nftId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    positionsNftIdOfUser(
      user_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    vaultByNftId(
      nftId_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
