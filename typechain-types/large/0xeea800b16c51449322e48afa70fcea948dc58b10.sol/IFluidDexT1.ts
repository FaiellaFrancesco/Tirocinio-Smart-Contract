/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace IFluidDexT1 {
  export type ImplementationsStruct = {
    shift: PromiseOrValue<string>;
    admin: PromiseOrValue<string>;
    colOperations: PromiseOrValue<string>;
    debtOperations: PromiseOrValue<string>;
    perfectOperationsAndOracle: PromiseOrValue<string>;
  };

  export type ImplementationsStructOutput = [
    string,
    string,
    string,
    string,
    string
  ] & {
    shift: string;
    admin: string;
    colOperations: string;
    debtOperations: string;
    perfectOperationsAndOracle: string;
  };

  export type ConstantViewsStruct = {
    dexId: PromiseOrValue<BigNumberish>;
    liquidity: PromiseOrValue<string>;
    factory: PromiseOrValue<string>;
    implementations: IFluidDexT1.ImplementationsStruct;
    deployerContract: PromiseOrValue<string>;
    token0: PromiseOrValue<string>;
    token1: PromiseOrValue<string>;
    supplyToken0Slot: PromiseOrValue<BytesLike>;
    borrowToken0Slot: PromiseOrValue<BytesLike>;
    supplyToken1Slot: PromiseOrValue<BytesLike>;
    borrowToken1Slot: PromiseOrValue<BytesLike>;
    exchangePriceToken0Slot: PromiseOrValue<BytesLike>;
    exchangePriceToken1Slot: PromiseOrValue<BytesLike>;
    oracleMapping: PromiseOrValue<BigNumberish>;
  };

  export type ConstantViewsStructOutput = [
    BigNumber,
    string,
    string,
    IFluidDexT1.ImplementationsStructOutput,
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber
  ] & {
    dexId: BigNumber;
    liquidity: string;
    factory: string;
    implementations: IFluidDexT1.ImplementationsStructOutput;
    deployerContract: string;
    token0: string;
    token1: string;
    supplyToken0Slot: string;
    borrowToken0Slot: string;
    supplyToken1Slot: string;
    borrowToken1Slot: string;
    exchangePriceToken0Slot: string;
    exchangePriceToken1Slot: string;
    oracleMapping: BigNumber;
  };

  export type ConstantViews2Struct = {
    token0NumeratorPrecision: PromiseOrValue<BigNumberish>;
    token0DenominatorPrecision: PromiseOrValue<BigNumberish>;
    token1NumeratorPrecision: PromiseOrValue<BigNumberish>;
    token1DenominatorPrecision: PromiseOrValue<BigNumberish>;
  };

  export type ConstantViews2StructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    token0NumeratorPrecision: BigNumber;
    token0DenominatorPrecision: BigNumber;
    token1NumeratorPrecision: BigNumber;
    token1DenominatorPrecision: BigNumber;
  };

  export type CollateralReservesStruct = {
    token0RealReserves: PromiseOrValue<BigNumberish>;
    token1RealReserves: PromiseOrValue<BigNumberish>;
    token0ImaginaryReserves: PromiseOrValue<BigNumberish>;
    token1ImaginaryReserves: PromiseOrValue<BigNumberish>;
  };

  export type CollateralReservesStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    token0RealReserves: BigNumber;
    token1RealReserves: BigNumber;
    token0ImaginaryReserves: BigNumber;
    token1ImaginaryReserves: BigNumber;
  };

  export type DebtReservesStruct = {
    token0Debt: PromiseOrValue<BigNumberish>;
    token1Debt: PromiseOrValue<BigNumberish>;
    token0RealReserves: PromiseOrValue<BigNumberish>;
    token1RealReserves: PromiseOrValue<BigNumberish>;
    token0ImaginaryReserves: PromiseOrValue<BigNumberish>;
    token1ImaginaryReserves: PromiseOrValue<BigNumberish>;
  };

  export type DebtReservesStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    token0Debt: BigNumber;
    token1Debt: BigNumber;
    token0RealReserves: BigNumber;
    token1RealReserves: BigNumber;
    token0ImaginaryReserves: BigNumber;
    token1ImaginaryReserves: BigNumber;
  };

  export type OracleStruct = {
    twap1by0: PromiseOrValue<BigNumberish>;
    lowestPrice1by0: PromiseOrValue<BigNumberish>;
    highestPrice1by0: PromiseOrValue<BigNumberish>;
    twap0by1: PromiseOrValue<BigNumberish>;
    lowestPrice0by1: PromiseOrValue<BigNumberish>;
    highestPrice0by1: PromiseOrValue<BigNumberish>;
  };

  export type OracleStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    twap1by0: BigNumber;
    lowestPrice1by0: BigNumber;
    highestPrice1by0: BigNumber;
    twap0by1: BigNumber;
    lowestPrice0by1: BigNumber;
    highestPrice0by1: BigNumber;
  };
}

export interface IFluidDexT1Interface extends utils.Interface {
  functions: {
    "DEX_ID()": FunctionFragment;
    "borrow(uint256,uint256,uint256,address)": FunctionFragment;
    "borrowPerfect(uint256,uint256,uint256,address)": FunctionFragment;
    "constantsView()": FunctionFragment;
    "constantsView2()": FunctionFragment;
    "deposit(uint256,uint256,uint256,bool)": FunctionFragment;
    "depositPerfect(uint256,uint256,uint256,bool)": FunctionFragment;
    "getCollateralReserves(uint256,uint256,uint256,uint256,uint256)": FunctionFragment;
    "getDebtReserves(uint256,uint256,uint256,uint256,uint256)": FunctionFragment;
    "getPricesAndExchangePrices()": FunctionFragment;
    "oraclePrice(uint256[])": FunctionFragment;
    "payback(uint256,uint256,uint256,bool)": FunctionFragment;
    "paybackPerfect(uint256,uint256,uint256,bool)": FunctionFragment;
    "paybackPerfectInOneToken(uint256,uint256,uint256,bool)": FunctionFragment;
    "readFromStorage(bytes32)": FunctionFragment;
    "swapIn(bool,uint256,uint256,address)": FunctionFragment;
    "swapOut(bool,uint256,uint256,address)": FunctionFragment;
    "withdraw(uint256,uint256,uint256,address)": FunctionFragment;
    "withdrawPerfect(uint256,uint256,uint256,address)": FunctionFragment;
    "withdrawPerfectInOneToken(uint256,uint256,uint256,address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DEX_ID"
      | "borrow"
      | "borrowPerfect"
      | "constantsView"
      | "constantsView2"
      | "deposit"
      | "depositPerfect"
      | "getCollateralReserves"
      | "getDebtReserves"
      | "getPricesAndExchangePrices"
      | "oraclePrice"
      | "payback"
      | "paybackPerfect"
      | "paybackPerfectInOneToken"
      | "readFromStorage"
      | "swapIn"
      | "swapOut"
      | "withdraw"
      | "withdrawPerfect"
      | "withdrawPerfectInOneToken"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "DEX_ID", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "borrow",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowPerfect",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "constantsView",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "constantsView2",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositPerfect",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getCollateralReserves",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getDebtReserves",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getPricesAndExchangePrices",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "oraclePrice",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "payback",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "paybackPerfect",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "paybackPerfectInOneToken",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "readFromStorage",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "swapIn",
    values: [
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapOut",
    values: [
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawPerfect",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawPerfectInOneToken",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;

  decodeFunctionResult(functionFragment: "DEX_ID", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "borrow", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "borrowPerfect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "constantsView",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "constantsView2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositPerfect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCollateralReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDebtReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPricesAndExchangePrices",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oraclePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "payback", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "paybackPerfect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "paybackPerfectInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readFromStorage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "swapIn", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "swapOut", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawPerfect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawPerfectInOneToken",
    data: BytesLike
  ): Result;

  events: {};
}

export interface IFluidDexT1 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IFluidDexT1Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DEX_ID(overrides?: CallOverrides): Promise<[BigNumber]>;

    borrow(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    borrowPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0Borrow_: PromiseOrValue<BigNumberish>,
      minToken1Borrow_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    constantsView(
      overrides?: CallOverrides
    ): Promise<
      [IFluidDexT1.ConstantViewsStructOutput] & {
        constantsView_: IFluidDexT1.ConstantViewsStructOutput;
      }
    >;

    constantsView2(
      overrides?: CallOverrides
    ): Promise<
      [IFluidDexT1.ConstantViews2StructOutput] & {
        constantsView2_: IFluidDexT1.ConstantViews2StructOutput;
      }
    >;

    deposit(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0Deposit_: PromiseOrValue<BigNumberish>,
      maxToken1Deposit_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getCollateralReserves(
      geometricMean_: PromiseOrValue<BigNumberish>,
      upperRange_: PromiseOrValue<BigNumberish>,
      lowerRange_: PromiseOrValue<BigNumberish>,
      token0SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
      token1SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [IFluidDexT1.CollateralReservesStructOutput] & {
        c_: IFluidDexT1.CollateralReservesStructOutput;
      }
    >;

    getDebtReserves(
      geometricMean_: PromiseOrValue<BigNumberish>,
      upperRange_: PromiseOrValue<BigNumberish>,
      lowerRange_: PromiseOrValue<BigNumberish>,
      token0BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
      token1BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [IFluidDexT1.DebtReservesStructOutput] & {
        d_: IFluidDexT1.DebtReservesStructOutput;
      }
    >;

    getPricesAndExchangePrices(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    oraclePrice(
      secondsAgos_: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [IFluidDexT1.OracleStructOutput[], BigNumber] & {
        twaps_: IFluidDexT1.OracleStructOutput[];
        currentPrice_: BigNumber;
      }
    >;

    payback(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    paybackPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0Payback_: PromiseOrValue<BigNumberish>,
      maxToken1Payback_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    paybackPerfectInOneToken(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0_: PromiseOrValue<BigNumberish>,
      maxToken1_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    readFromStorage(
      slot_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { result_: BigNumber }>;

    swapIn(
      swap0to1_: PromiseOrValue<boolean>,
      amountIn_: PromiseOrValue<BigNumberish>,
      amountOutMin_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapOut(
      swap0to1_: PromiseOrValue<boolean>,
      amountOut_: PromiseOrValue<BigNumberish>,
      amountInMax_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0Withdraw_: PromiseOrValue<BigNumberish>,
      minToken1Withdraw_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawPerfectInOneToken(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0_: PromiseOrValue<BigNumberish>,
      minToken1_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  DEX_ID(overrides?: CallOverrides): Promise<BigNumber>;

  borrow(
    token0Amt_: PromiseOrValue<BigNumberish>,
    token1Amt_: PromiseOrValue<BigNumberish>,
    maxSharesAmt_: PromiseOrValue<BigNumberish>,
    to_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  borrowPerfect(
    shares_: PromiseOrValue<BigNumberish>,
    minToken0Borrow_: PromiseOrValue<BigNumberish>,
    minToken1Borrow_: PromiseOrValue<BigNumberish>,
    to_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  constantsView(
    overrides?: CallOverrides
  ): Promise<IFluidDexT1.ConstantViewsStructOutput>;

  constantsView2(
    overrides?: CallOverrides
  ): Promise<IFluidDexT1.ConstantViews2StructOutput>;

  deposit(
    token0Amt_: PromiseOrValue<BigNumberish>,
    token1Amt_: PromiseOrValue<BigNumberish>,
    minSharesAmt_: PromiseOrValue<BigNumberish>,
    estimate_: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositPerfect(
    shares_: PromiseOrValue<BigNumberish>,
    maxToken0Deposit_: PromiseOrValue<BigNumberish>,
    maxToken1Deposit_: PromiseOrValue<BigNumberish>,
    estimate_: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getCollateralReserves(
    geometricMean_: PromiseOrValue<BigNumberish>,
    upperRange_: PromiseOrValue<BigNumberish>,
    lowerRange_: PromiseOrValue<BigNumberish>,
    token0SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
    token1SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IFluidDexT1.CollateralReservesStructOutput>;

  getDebtReserves(
    geometricMean_: PromiseOrValue<BigNumberish>,
    upperRange_: PromiseOrValue<BigNumberish>,
    lowerRange_: PromiseOrValue<BigNumberish>,
    token0BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
    token1BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IFluidDexT1.DebtReservesStructOutput>;

  getPricesAndExchangePrices(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  oraclePrice(
    secondsAgos_: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<
    [IFluidDexT1.OracleStructOutput[], BigNumber] & {
      twaps_: IFluidDexT1.OracleStructOutput[];
      currentPrice_: BigNumber;
    }
  >;

  payback(
    token0Amt_: PromiseOrValue<BigNumberish>,
    token1Amt_: PromiseOrValue<BigNumberish>,
    minSharesAmt_: PromiseOrValue<BigNumberish>,
    estimate_: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  paybackPerfect(
    shares_: PromiseOrValue<BigNumberish>,
    maxToken0Payback_: PromiseOrValue<BigNumberish>,
    maxToken1Payback_: PromiseOrValue<BigNumberish>,
    estimate_: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  paybackPerfectInOneToken(
    shares_: PromiseOrValue<BigNumberish>,
    maxToken0_: PromiseOrValue<BigNumberish>,
    maxToken1_: PromiseOrValue<BigNumberish>,
    estimate_: PromiseOrValue<boolean>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  readFromStorage(
    slot_: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  swapIn(
    swap0to1_: PromiseOrValue<boolean>,
    amountIn_: PromiseOrValue<BigNumberish>,
    amountOutMin_: PromiseOrValue<BigNumberish>,
    to_: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapOut(
    swap0to1_: PromiseOrValue<boolean>,
    amountOut_: PromiseOrValue<BigNumberish>,
    amountInMax_: PromiseOrValue<BigNumberish>,
    to_: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    token0Amt_: PromiseOrValue<BigNumberish>,
    token1Amt_: PromiseOrValue<BigNumberish>,
    maxSharesAmt_: PromiseOrValue<BigNumberish>,
    to_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawPerfect(
    shares_: PromiseOrValue<BigNumberish>,
    minToken0Withdraw_: PromiseOrValue<BigNumberish>,
    minToken1Withdraw_: PromiseOrValue<BigNumberish>,
    to_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawPerfectInOneToken(
    shares_: PromiseOrValue<BigNumberish>,
    minToken0_: PromiseOrValue<BigNumberish>,
    minToken1_: PromiseOrValue<BigNumberish>,
    to_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    DEX_ID(overrides?: CallOverrides): Promise<BigNumber>;

    borrow(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrowPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0Borrow_: PromiseOrValue<BigNumberish>,
      minToken1Borrow_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { token0Amt_: BigNumber; token1Amt_: BigNumber }
    >;

    constantsView(
      overrides?: CallOverrides
    ): Promise<IFluidDexT1.ConstantViewsStructOutput>;

    constantsView2(
      overrides?: CallOverrides
    ): Promise<IFluidDexT1.ConstantViews2StructOutput>;

    deposit(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    depositPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0Deposit_: PromiseOrValue<BigNumberish>,
      maxToken1Deposit_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { token0Amt_: BigNumber; token1Amt_: BigNumber }
    >;

    getCollateralReserves(
      geometricMean_: PromiseOrValue<BigNumberish>,
      upperRange_: PromiseOrValue<BigNumberish>,
      lowerRange_: PromiseOrValue<BigNumberish>,
      token0SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
      token1SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IFluidDexT1.CollateralReservesStructOutput>;

    getDebtReserves(
      geometricMean_: PromiseOrValue<BigNumberish>,
      upperRange_: PromiseOrValue<BigNumberish>,
      lowerRange_: PromiseOrValue<BigNumberish>,
      token0BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
      token1BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IFluidDexT1.DebtReservesStructOutput>;

    getPricesAndExchangePrices(overrides?: CallOverrides): Promise<void>;

    oraclePrice(
      secondsAgos_: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [IFluidDexT1.OracleStructOutput[], BigNumber] & {
        twaps_: IFluidDexT1.OracleStructOutput[];
        currentPrice_: BigNumber;
      }
    >;

    payback(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    paybackPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0Payback_: PromiseOrValue<BigNumberish>,
      maxToken1Payback_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { token0Amt_: BigNumber; token1Amt_: BigNumber }
    >;

    paybackPerfectInOneToken(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0_: PromiseOrValue<BigNumberish>,
      maxToken1_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    readFromStorage(
      slot_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapIn(
      swap0to1_: PromiseOrValue<boolean>,
      amountIn_: PromiseOrValue<BigNumberish>,
      amountOutMin_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapOut(
      swap0to1_: PromiseOrValue<boolean>,
      amountOut_: PromiseOrValue<BigNumberish>,
      amountInMax_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdraw(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdrawPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0Withdraw_: PromiseOrValue<BigNumberish>,
      minToken1Withdraw_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { token0Amt_: BigNumber; token1Amt_: BigNumber }
    >;

    withdrawPerfectInOneToken(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0_: PromiseOrValue<BigNumberish>,
      minToken1_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {};

  estimateGas: {
    DEX_ID(overrides?: CallOverrides): Promise<BigNumber>;

    borrow(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    borrowPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0Borrow_: PromiseOrValue<BigNumberish>,
      minToken1Borrow_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    constantsView(overrides?: CallOverrides): Promise<BigNumber>;

    constantsView2(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0Deposit_: PromiseOrValue<BigNumberish>,
      maxToken1Deposit_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getCollateralReserves(
      geometricMean_: PromiseOrValue<BigNumberish>,
      upperRange_: PromiseOrValue<BigNumberish>,
      lowerRange_: PromiseOrValue<BigNumberish>,
      token0SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
      token1SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDebtReserves(
      geometricMean_: PromiseOrValue<BigNumberish>,
      upperRange_: PromiseOrValue<BigNumberish>,
      lowerRange_: PromiseOrValue<BigNumberish>,
      token0BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
      token1BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPricesAndExchangePrices(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    oraclePrice(
      secondsAgos_: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    payback(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    paybackPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0Payback_: PromiseOrValue<BigNumberish>,
      maxToken1Payback_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    paybackPerfectInOneToken(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0_: PromiseOrValue<BigNumberish>,
      maxToken1_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    readFromStorage(
      slot_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapIn(
      swap0to1_: PromiseOrValue<boolean>,
      amountIn_: PromiseOrValue<BigNumberish>,
      amountOutMin_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapOut(
      swap0to1_: PromiseOrValue<boolean>,
      amountOut_: PromiseOrValue<BigNumberish>,
      amountInMax_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0Withdraw_: PromiseOrValue<BigNumberish>,
      minToken1Withdraw_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawPerfectInOneToken(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0_: PromiseOrValue<BigNumberish>,
      minToken1_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DEX_ID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    borrow(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    borrowPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0Borrow_: PromiseOrValue<BigNumberish>,
      minToken1Borrow_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    constantsView(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    constantsView2(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0Deposit_: PromiseOrValue<BigNumberish>,
      maxToken1Deposit_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getCollateralReserves(
      geometricMean_: PromiseOrValue<BigNumberish>,
      upperRange_: PromiseOrValue<BigNumberish>,
      lowerRange_: PromiseOrValue<BigNumberish>,
      token0SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
      token1SupplyExchangePrice_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDebtReserves(
      geometricMean_: PromiseOrValue<BigNumberish>,
      upperRange_: PromiseOrValue<BigNumberish>,
      lowerRange_: PromiseOrValue<BigNumberish>,
      token0BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
      token1BorrowExchangePrice_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPricesAndExchangePrices(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    oraclePrice(
      secondsAgos_: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    payback(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      minSharesAmt_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    paybackPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0Payback_: PromiseOrValue<BigNumberish>,
      maxToken1Payback_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    paybackPerfectInOneToken(
      shares_: PromiseOrValue<BigNumberish>,
      maxToken0_: PromiseOrValue<BigNumberish>,
      maxToken1_: PromiseOrValue<BigNumberish>,
      estimate_: PromiseOrValue<boolean>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    readFromStorage(
      slot_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    swapIn(
      swap0to1_: PromiseOrValue<boolean>,
      amountIn_: PromiseOrValue<BigNumberish>,
      amountOutMin_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapOut(
      swap0to1_: PromiseOrValue<boolean>,
      amountOut_: PromiseOrValue<BigNumberish>,
      amountInMax_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      token0Amt_: PromiseOrValue<BigNumberish>,
      token1Amt_: PromiseOrValue<BigNumberish>,
      maxSharesAmt_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawPerfect(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0Withdraw_: PromiseOrValue<BigNumberish>,
      minToken1Withdraw_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawPerfectInOneToken(
      shares_: PromiseOrValue<BigNumberish>,
      minToken0_: PromiseOrValue<BigNumberish>,
      minToken1_: PromiseOrValue<BigNumberish>,
      to_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
