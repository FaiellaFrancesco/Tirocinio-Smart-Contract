/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export declare namespace IFluidDexT1 {
  export type ImplementationsStruct = {
    shift: AddressLike;
    admin: AddressLike;
    colOperations: AddressLike;
    debtOperations: AddressLike;
    perfectOperationsAndOracle: AddressLike;
  };

  export type ImplementationsStructOutput = [
    shift: string,
    admin: string,
    colOperations: string,
    debtOperations: string,
    perfectOperationsAndOracle: string
  ] & {
    shift: string;
    admin: string;
    colOperations: string;
    debtOperations: string;
    perfectOperationsAndOracle: string;
  };

  export type ConstantViewsStruct = {
    dexId: BigNumberish;
    liquidity: AddressLike;
    factory: AddressLike;
    implementations: IFluidDexT1.ImplementationsStruct;
    deployerContract: AddressLike;
    token0: AddressLike;
    token1: AddressLike;
    supplyToken0Slot: BytesLike;
    borrowToken0Slot: BytesLike;
    supplyToken1Slot: BytesLike;
    borrowToken1Slot: BytesLike;
    exchangePriceToken0Slot: BytesLike;
    exchangePriceToken1Slot: BytesLike;
    oracleMapping: BigNumberish;
  };

  export type ConstantViewsStructOutput = [
    dexId: bigint,
    liquidity: string,
    factory: string,
    implementations: IFluidDexT1.ImplementationsStructOutput,
    deployerContract: string,
    token0: string,
    token1: string,
    supplyToken0Slot: string,
    borrowToken0Slot: string,
    supplyToken1Slot: string,
    borrowToken1Slot: string,
    exchangePriceToken0Slot: string,
    exchangePriceToken1Slot: string,
    oracleMapping: bigint
  ] & {
    dexId: bigint;
    liquidity: string;
    factory: string;
    implementations: IFluidDexT1.ImplementationsStructOutput;
    deployerContract: string;
    token0: string;
    token1: string;
    supplyToken0Slot: string;
    borrowToken0Slot: string;
    supplyToken1Slot: string;
    borrowToken1Slot: string;
    exchangePriceToken0Slot: string;
    exchangePriceToken1Slot: string;
    oracleMapping: bigint;
  };

  export type ConstantViews2Struct = {
    token0NumeratorPrecision: BigNumberish;
    token0DenominatorPrecision: BigNumberish;
    token1NumeratorPrecision: BigNumberish;
    token1DenominatorPrecision: BigNumberish;
  };

  export type ConstantViews2StructOutput = [
    token0NumeratorPrecision: bigint,
    token0DenominatorPrecision: bigint,
    token1NumeratorPrecision: bigint,
    token1DenominatorPrecision: bigint
  ] & {
    token0NumeratorPrecision: bigint;
    token0DenominatorPrecision: bigint;
    token1NumeratorPrecision: bigint;
    token1DenominatorPrecision: bigint;
  };

  export type CollateralReservesStruct = {
    token0RealReserves: BigNumberish;
    token1RealReserves: BigNumberish;
    token0ImaginaryReserves: BigNumberish;
    token1ImaginaryReserves: BigNumberish;
  };

  export type CollateralReservesStructOutput = [
    token0RealReserves: bigint,
    token1RealReserves: bigint,
    token0ImaginaryReserves: bigint,
    token1ImaginaryReserves: bigint
  ] & {
    token0RealReserves: bigint;
    token1RealReserves: bigint;
    token0ImaginaryReserves: bigint;
    token1ImaginaryReserves: bigint;
  };

  export type DebtReservesStruct = {
    token0Debt: BigNumberish;
    token1Debt: BigNumberish;
    token0RealReserves: BigNumberish;
    token1RealReserves: BigNumberish;
    token0ImaginaryReserves: BigNumberish;
    token1ImaginaryReserves: BigNumberish;
  };

  export type DebtReservesStructOutput = [
    token0Debt: bigint,
    token1Debt: bigint,
    token0RealReserves: bigint,
    token1RealReserves: bigint,
    token0ImaginaryReserves: bigint,
    token1ImaginaryReserves: bigint
  ] & {
    token0Debt: bigint;
    token1Debt: bigint;
    token0RealReserves: bigint;
    token1RealReserves: bigint;
    token0ImaginaryReserves: bigint;
    token1ImaginaryReserves: bigint;
  };

  export type OracleStruct = {
    twap1by0: BigNumberish;
    lowestPrice1by0: BigNumberish;
    highestPrice1by0: BigNumberish;
    twap0by1: BigNumberish;
    lowestPrice0by1: BigNumberish;
    highestPrice0by1: BigNumberish;
  };

  export type OracleStructOutput = [
    twap1by0: bigint,
    lowestPrice1by0: bigint,
    highestPrice1by0: bigint,
    twap0by1: bigint,
    lowestPrice0by1: bigint,
    highestPrice0by1: bigint
  ] & {
    twap1by0: bigint;
    lowestPrice1by0: bigint;
    highestPrice1by0: bigint;
    twap0by1: bigint;
    lowestPrice0by1: bigint;
    highestPrice0by1: bigint;
  };
}

export interface IFluidDexT1Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "DEX_ID"
      | "borrow"
      | "borrowPerfect"
      | "constantsView"
      | "constantsView2"
      | "deposit"
      | "depositPerfect"
      | "getCollateralReserves"
      | "getDebtReserves"
      | "getPricesAndExchangePrices"
      | "oraclePrice"
      | "payback"
      | "paybackPerfect"
      | "paybackPerfectInOneToken"
      | "readFromStorage"
      | "swapIn"
      | "swapOut"
      | "withdraw"
      | "withdrawPerfect"
      | "withdrawPerfectInOneToken"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "DEX_ID", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "borrow",
    values: [BigNumberish, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowPerfect",
    values: [BigNumberish, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "constantsView",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "constantsView2",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [BigNumberish, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "depositPerfect",
    values: [BigNumberish, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getCollateralReserves",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getDebtReserves",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getPricesAndExchangePrices",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "oraclePrice",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "payback",
    values: [BigNumberish, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "paybackPerfect",
    values: [BigNumberish, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "paybackPerfectInOneToken",
    values: [BigNumberish, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "readFromStorage",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "swapIn",
    values: [boolean, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "swapOut",
    values: [boolean, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [BigNumberish, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawPerfect",
    values: [BigNumberish, BigNumberish, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawPerfectInOneToken",
    values: [BigNumberish, BigNumberish, BigNumberish, AddressLike]
  ): string;

  decodeFunctionResult(functionFragment: "DEX_ID", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "borrow", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "borrowPerfect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "constantsView",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "constantsView2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositPerfect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCollateralReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDebtReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPricesAndExchangePrices",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oraclePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "payback", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "paybackPerfect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "paybackPerfectInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "readFromStorage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "swapIn", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "swapOut", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawPerfect",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawPerfectInOneToken",
    data: BytesLike
  ): Result;
}

export interface IFluidDexT1 extends BaseContract {
  connect(runner?: ContractRunner | null): IFluidDexT1;
  waitForDeployment(): Promise<this>;

  interface: IFluidDexT1Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  DEX_ID: TypedContractMethod<[], [bigint], "view">;

  borrow: TypedContractMethod<
    [
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      maxSharesAmt_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;

  borrowPerfect: TypedContractMethod<
    [
      shares_: BigNumberish,
      minToken0Borrow_: BigNumberish,
      minToken1Borrow_: BigNumberish,
      to_: AddressLike
    ],
    [[bigint, bigint] & { token0Amt_: bigint; token1Amt_: bigint }],
    "nonpayable"
  >;

  constantsView: TypedContractMethod<
    [],
    [IFluidDexT1.ConstantViewsStructOutput],
    "view"
  >;

  constantsView2: TypedContractMethod<
    [],
    [IFluidDexT1.ConstantViews2StructOutput],
    "view"
  >;

  deposit: TypedContractMethod<
    [
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      minSharesAmt_: BigNumberish,
      estimate_: boolean
    ],
    [bigint],
    "payable"
  >;

  depositPerfect: TypedContractMethod<
    [
      shares_: BigNumberish,
      maxToken0Deposit_: BigNumberish,
      maxToken1Deposit_: BigNumberish,
      estimate_: boolean
    ],
    [[bigint, bigint] & { token0Amt_: bigint; token1Amt_: bigint }],
    "payable"
  >;

  getCollateralReserves: TypedContractMethod<
    [
      geometricMean_: BigNumberish,
      upperRange_: BigNumberish,
      lowerRange_: BigNumberish,
      token0SupplyExchangePrice_: BigNumberish,
      token1SupplyExchangePrice_: BigNumberish
    ],
    [IFluidDexT1.CollateralReservesStructOutput],
    "view"
  >;

  getDebtReserves: TypedContractMethod<
    [
      geometricMean_: BigNumberish,
      upperRange_: BigNumberish,
      lowerRange_: BigNumberish,
      token0BorrowExchangePrice_: BigNumberish,
      token1BorrowExchangePrice_: BigNumberish
    ],
    [IFluidDexT1.DebtReservesStructOutput],
    "view"
  >;

  getPricesAndExchangePrices: TypedContractMethod<[], [void], "nonpayable">;

  oraclePrice: TypedContractMethod<
    [secondsAgos_: BigNumberish[]],
    [
      [IFluidDexT1.OracleStructOutput[], bigint] & {
        twaps_: IFluidDexT1.OracleStructOutput[];
        currentPrice_: bigint;
      }
    ],
    "view"
  >;

  payback: TypedContractMethod<
    [
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      minSharesAmt_: BigNumberish,
      estimate_: boolean
    ],
    [bigint],
    "payable"
  >;

  paybackPerfect: TypedContractMethod<
    [
      shares_: BigNumberish,
      maxToken0Payback_: BigNumberish,
      maxToken1Payback_: BigNumberish,
      estimate_: boolean
    ],
    [[bigint, bigint] & { token0Amt_: bigint; token1Amt_: bigint }],
    "payable"
  >;

  paybackPerfectInOneToken: TypedContractMethod<
    [
      shares_: BigNumberish,
      maxToken0_: BigNumberish,
      maxToken1_: BigNumberish,
      estimate_: boolean
    ],
    [bigint],
    "payable"
  >;

  readFromStorage: TypedContractMethod<[slot_: BytesLike], [bigint], "view">;

  swapIn: TypedContractMethod<
    [
      swap0to1_: boolean,
      amountIn_: BigNumberish,
      amountOutMin_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "payable"
  >;

  swapOut: TypedContractMethod<
    [
      swap0to1_: boolean,
      amountOut_: BigNumberish,
      amountInMax_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "payable"
  >;

  withdraw: TypedContractMethod<
    [
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      maxSharesAmt_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;

  withdrawPerfect: TypedContractMethod<
    [
      shares_: BigNumberish,
      minToken0Withdraw_: BigNumberish,
      minToken1Withdraw_: BigNumberish,
      to_: AddressLike
    ],
    [[bigint, bigint] & { token0Amt_: bigint; token1Amt_: bigint }],
    "nonpayable"
  >;

  withdrawPerfectInOneToken: TypedContractMethod<
    [
      shares_: BigNumberish,
      minToken0_: BigNumberish,
      minToken1_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "DEX_ID"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "borrow"
  ): TypedContractMethod<
    [
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      maxSharesAmt_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "borrowPerfect"
  ): TypedContractMethod<
    [
      shares_: BigNumberish,
      minToken0Borrow_: BigNumberish,
      minToken1Borrow_: BigNumberish,
      to_: AddressLike
    ],
    [[bigint, bigint] & { token0Amt_: bigint; token1Amt_: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "constantsView"
  ): TypedContractMethod<[], [IFluidDexT1.ConstantViewsStructOutput], "view">;
  getFunction(
    nameOrSignature: "constantsView2"
  ): TypedContractMethod<[], [IFluidDexT1.ConstantViews2StructOutput], "view">;
  getFunction(
    nameOrSignature: "deposit"
  ): TypedContractMethod<
    [
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      minSharesAmt_: BigNumberish,
      estimate_: boolean
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "depositPerfect"
  ): TypedContractMethod<
    [
      shares_: BigNumberish,
      maxToken0Deposit_: BigNumberish,
      maxToken1Deposit_: BigNumberish,
      estimate_: boolean
    ],
    [[bigint, bigint] & { token0Amt_: bigint; token1Amt_: bigint }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "getCollateralReserves"
  ): TypedContractMethod<
    [
      geometricMean_: BigNumberish,
      upperRange_: BigNumberish,
      lowerRange_: BigNumberish,
      token0SupplyExchangePrice_: BigNumberish,
      token1SupplyExchangePrice_: BigNumberish
    ],
    [IFluidDexT1.CollateralReservesStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getDebtReserves"
  ): TypedContractMethod<
    [
      geometricMean_: BigNumberish,
      upperRange_: BigNumberish,
      lowerRange_: BigNumberish,
      token0BorrowExchangePrice_: BigNumberish,
      token1BorrowExchangePrice_: BigNumberish
    ],
    [IFluidDexT1.DebtReservesStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPricesAndExchangePrices"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "oraclePrice"
  ): TypedContractMethod<
    [secondsAgos_: BigNumberish[]],
    [
      [IFluidDexT1.OracleStructOutput[], bigint] & {
        twaps_: IFluidDexT1.OracleStructOutput[];
        currentPrice_: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "payback"
  ): TypedContractMethod<
    [
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      minSharesAmt_: BigNumberish,
      estimate_: boolean
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "paybackPerfect"
  ): TypedContractMethod<
    [
      shares_: BigNumberish,
      maxToken0Payback_: BigNumberish,
      maxToken1Payback_: BigNumberish,
      estimate_: boolean
    ],
    [[bigint, bigint] & { token0Amt_: bigint; token1Amt_: bigint }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "paybackPerfectInOneToken"
  ): TypedContractMethod<
    [
      shares_: BigNumberish,
      maxToken0_: BigNumberish,
      maxToken1_: BigNumberish,
      estimate_: boolean
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "readFromStorage"
  ): TypedContractMethod<[slot_: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "swapIn"
  ): TypedContractMethod<
    [
      swap0to1_: boolean,
      amountIn_: BigNumberish,
      amountOutMin_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "swapOut"
  ): TypedContractMethod<
    [
      swap0to1_: boolean,
      amountOut_: BigNumberish,
      amountInMax_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "withdraw"
  ): TypedContractMethod<
    [
      token0Amt_: BigNumberish,
      token1Amt_: BigNumberish,
      maxSharesAmt_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "withdrawPerfect"
  ): TypedContractMethod<
    [
      shares_: BigNumberish,
      minToken0Withdraw_: BigNumberish,
      minToken1Withdraw_: BigNumberish,
      to_: AddressLike
    ],
    [[bigint, bigint] & { token0Amt_: bigint; token1Amt_: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "withdrawPerfectInOneToken"
  ): TypedContractMethod<
    [
      shares_: BigNumberish,
      minToken0_: BigNumberish,
      minToken1_: BigNumberish,
      to_: AddressLike
    ],
    [bigint],
    "nonpayable"
  >;

  filters: {};
}
