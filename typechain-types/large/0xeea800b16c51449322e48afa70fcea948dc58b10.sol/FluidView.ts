/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace FluidView {
  export type FTokenDataStruct = {
    tokenAddress: PromiseOrValue<string>;
    isNativeUnderlying: PromiseOrValue<boolean>;
    name: PromiseOrValue<string>;
    symbol: PromiseOrValue<string>;
    decimals: PromiseOrValue<BigNumberish>;
    asset: PromiseOrValue<string>;
    totalAssets: PromiseOrValue<BigNumberish>;
    totalSupply: PromiseOrValue<BigNumberish>;
    convertToShares: PromiseOrValue<BigNumberish>;
    convertToAssets: PromiseOrValue<BigNumberish>;
    rewardsRate: PromiseOrValue<BigNumberish>;
    supplyRate: PromiseOrValue<BigNumberish>;
    withdrawable: PromiseOrValue<BigNumberish>;
    modeWithInterest: PromiseOrValue<boolean>;
    expandPercent: PromiseOrValue<BigNumberish>;
    expandDuration: PromiseOrValue<BigNumberish>;
  };

  export type FTokenDataStructOutput = [
    string,
    boolean,
    string,
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean,
    BigNumber,
    BigNumber
  ] & {
    tokenAddress: string;
    isNativeUnderlying: boolean;
    name: string;
    symbol: string;
    decimals: BigNumber;
    asset: string;
    totalAssets: BigNumber;
    totalSupply: BigNumber;
    convertToShares: BigNumber;
    convertToAssets: BigNumber;
    rewardsRate: BigNumber;
    supplyRate: BigNumber;
    withdrawable: BigNumber;
    modeWithInterest: boolean;
    expandPercent: BigNumber;
    expandDuration: BigNumber;
  };

  export type UserEarnPositionStruct = {
    fTokenShares: PromiseOrValue<BigNumberish>;
    underlyingAssets: PromiseOrValue<BigNumberish>;
    underlyingBalance: PromiseOrValue<BigNumberish>;
    allowance: PromiseOrValue<BigNumberish>;
  };

  export type UserEarnPositionStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    fTokenShares: BigNumber;
    underlyingAssets: BigNumber;
    underlyingBalance: BigNumber;
    allowance: BigNumber;
  };

  export type UserPositionStruct = {
    nftId: PromiseOrValue<BigNumberish>;
    owner: PromiseOrValue<string>;
    isLiquidated: PromiseOrValue<boolean>;
    isSupplyPosition: PromiseOrValue<boolean>;
    supply: PromiseOrValue<BigNumberish>;
    borrow: PromiseOrValue<BigNumberish>;
    ratio: PromiseOrValue<BigNumberish>;
    tick: PromiseOrValue<BigNumberish>;
    tickId: PromiseOrValue<BigNumberish>;
  };

  export type UserPositionStructOutput = [
    BigNumber,
    string,
    boolean,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    nftId: BigNumber;
    owner: string;
    isLiquidated: boolean;
    isSupplyPosition: boolean;
    supply: BigNumber;
    borrow: BigNumber;
    ratio: BigNumber;
    tick: BigNumber;
    tickId: BigNumber;
  };

  export type DexSupplyDataStruct = {
    dexPool: PromiseOrValue<string>;
    dexId: PromiseOrValue<BigNumberish>;
    fee: PromiseOrValue<BigNumberish>;
    lastStoredPrice: PromiseOrValue<BigNumberish>;
    centerPrice: PromiseOrValue<BigNumberish>;
    token0Utilization: PromiseOrValue<BigNumberish>;
    token1Utilization: PromiseOrValue<BigNumberish>;
    totalSupplyShares: PromiseOrValue<BigNumberish>;
    maxSupplyShares: PromiseOrValue<BigNumberish>;
    token0Supplied: PromiseOrValue<BigNumberish>;
    token1Supplied: PromiseOrValue<BigNumberish>;
    sharesWithdrawable: PromiseOrValue<BigNumberish>;
    token0Withdrawable: PromiseOrValue<BigNumberish>;
    token1Withdrawable: PromiseOrValue<BigNumberish>;
    token0PerSupplyShare: PromiseOrValue<BigNumberish>;
    token1PerSupplyShare: PromiseOrValue<BigNumberish>;
    token0SupplyRate: PromiseOrValue<BigNumberish>;
    token1SupplyRate: PromiseOrValue<BigNumberish>;
    quoteToken: PromiseOrValue<string>;
    quoteTokensPerShare: PromiseOrValue<BigNumberish>;
    supplyToken0Reserves: PromiseOrValue<BigNumberish>;
    supplyToken1Reserves: PromiseOrValue<BigNumberish>;
  };

  export type DexSupplyDataStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    dexPool: string;
    dexId: BigNumber;
    fee: BigNumber;
    lastStoredPrice: BigNumber;
    centerPrice: BigNumber;
    token0Utilization: BigNumber;
    token1Utilization: BigNumber;
    totalSupplyShares: BigNumber;
    maxSupplyShares: BigNumber;
    token0Supplied: BigNumber;
    token1Supplied: BigNumber;
    sharesWithdrawable: BigNumber;
    token0Withdrawable: BigNumber;
    token1Withdrawable: BigNumber;
    token0PerSupplyShare: BigNumber;
    token1PerSupplyShare: BigNumber;
    token0SupplyRate: BigNumber;
    token1SupplyRate: BigNumber;
    quoteToken: string;
    quoteTokensPerShare: BigNumber;
    supplyToken0Reserves: BigNumber;
    supplyToken1Reserves: BigNumber;
  };

  export type DexBorrowDataStruct = {
    dexPool: PromiseOrValue<string>;
    dexId: PromiseOrValue<BigNumberish>;
    fee: PromiseOrValue<BigNumberish>;
    lastStoredPrice: PromiseOrValue<BigNumberish>;
    centerPrice: PromiseOrValue<BigNumberish>;
    token0Utilization: PromiseOrValue<BigNumberish>;
    token1Utilization: PromiseOrValue<BigNumberish>;
    totalBorrowShares: PromiseOrValue<BigNumberish>;
    maxBorrowShares: PromiseOrValue<BigNumberish>;
    token0Borrowed: PromiseOrValue<BigNumberish>;
    token1Borrowed: PromiseOrValue<BigNumberish>;
    sharesBorrowable: PromiseOrValue<BigNumberish>;
    token0Borrowable: PromiseOrValue<BigNumberish>;
    token1Borrowable: PromiseOrValue<BigNumberish>;
    token0PerBorrowShare: PromiseOrValue<BigNumberish>;
    token1PerBorrowShare: PromiseOrValue<BigNumberish>;
    token0BorrowRate: PromiseOrValue<BigNumberish>;
    token1BorrowRate: PromiseOrValue<BigNumberish>;
    quoteToken: PromiseOrValue<string>;
    quoteTokensPerShare: PromiseOrValue<BigNumberish>;
    borrowToken0Reserves: PromiseOrValue<BigNumberish>;
    borrowToken1Reserves: PromiseOrValue<BigNumberish>;
  };

  export type DexBorrowDataStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    dexPool: string;
    dexId: BigNumber;
    fee: BigNumber;
    lastStoredPrice: BigNumber;
    centerPrice: BigNumber;
    token0Utilization: BigNumber;
    token1Utilization: BigNumber;
    totalBorrowShares: BigNumber;
    maxBorrowShares: BigNumber;
    token0Borrowed: BigNumber;
    token1Borrowed: BigNumber;
    sharesBorrowable: BigNumber;
    token0Borrowable: BigNumber;
    token1Borrowable: BigNumber;
    token0PerBorrowShare: BigNumber;
    token1PerBorrowShare: BigNumber;
    token0BorrowRate: BigNumber;
    token1BorrowRate: BigNumber;
    quoteToken: string;
    quoteTokensPerShare: BigNumber;
    borrowToken0Reserves: BigNumber;
    borrowToken1Reserves: BigNumber;
  };

  export type VaultDataStruct = {
    vault: PromiseOrValue<string>;
    vaultId: PromiseOrValue<BigNumberish>;
    vaultType: PromiseOrValue<BigNumberish>;
    isSmartColl: PromiseOrValue<boolean>;
    isSmartDebt: PromiseOrValue<boolean>;
    supplyToken0: PromiseOrValue<string>;
    supplyToken1: PromiseOrValue<string>;
    borrowToken0: PromiseOrValue<string>;
    borrowToken1: PromiseOrValue<string>;
    supplyToken0Decimals: PromiseOrValue<BigNumberish>;
    supplyToken1Decimals: PromiseOrValue<BigNumberish>;
    borrowToken0Decimals: PromiseOrValue<BigNumberish>;
    borrowToken1Decimals: PromiseOrValue<BigNumberish>;
    collateralFactor: PromiseOrValue<BigNumberish>;
    liquidationThreshold: PromiseOrValue<BigNumberish>;
    liquidationMaxLimit: PromiseOrValue<BigNumberish>;
    withdrawalGap: PromiseOrValue<BigNumberish>;
    liquidationPenalty: PromiseOrValue<BigNumberish>;
    borrowFee: PromiseOrValue<BigNumberish>;
    oracle: PromiseOrValue<string>;
    oraclePriceOperate: PromiseOrValue<BigNumberish>;
    oraclePriceLiquidate: PromiseOrValue<BigNumberish>;
    vaultSupplyExchangePrice: PromiseOrValue<BigNumberish>;
    vaultBorrowExchangePrice: PromiseOrValue<BigNumberish>;
    supplyRateVault: PromiseOrValue<BigNumberish>;
    borrowRateVault: PromiseOrValue<BigNumberish>;
    rewardsOrFeeRateSupply: PromiseOrValue<BigNumberish>;
    rewardsOrFeeRateBorrow: PromiseOrValue<BigNumberish>;
    totalPositions: PromiseOrValue<BigNumberish>;
    totalSupplyVault: PromiseOrValue<BigNumberish>;
    totalBorrowVault: PromiseOrValue<BigNumberish>;
    withdrawalLimit: PromiseOrValue<BigNumberish>;
    withdrawableUntilLimit: PromiseOrValue<BigNumberish>;
    withdrawable: PromiseOrValue<BigNumberish>;
    baseWithdrawalLimit: PromiseOrValue<BigNumberish>;
    withdrawExpandPercent: PromiseOrValue<BigNumberish>;
    withdrawExpandDuration: PromiseOrValue<BigNumberish>;
    borrowLimit: PromiseOrValue<BigNumberish>;
    borrowableUntilLimit: PromiseOrValue<BigNumberish>;
    borrowable: PromiseOrValue<BigNumberish>;
    borrowLimitUtilization: PromiseOrValue<BigNumberish>;
    maxBorrowLimit: PromiseOrValue<BigNumberish>;
    borrowExpandPercent: PromiseOrValue<BigNumberish>;
    borrowExpandDuration: PromiseOrValue<BigNumberish>;
    baseBorrowLimit: PromiseOrValue<BigNumberish>;
    minimumBorrowing: PromiseOrValue<BigNumberish>;
    dexSupplyData: FluidView.DexSupplyDataStruct;
    dexBorrowData: FluidView.DexBorrowDataStruct;
  };

  export type VaultDataStructOutput = [
    string,
    BigNumber,
    BigNumber,
    boolean,
    boolean,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    number,
    number,
    number,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    FluidView.DexSupplyDataStructOutput,
    FluidView.DexBorrowDataStructOutput
  ] & {
    vault: string;
    vaultId: BigNumber;
    vaultType: BigNumber;
    isSmartColl: boolean;
    isSmartDebt: boolean;
    supplyToken0: string;
    supplyToken1: string;
    borrowToken0: string;
    borrowToken1: string;
    supplyToken0Decimals: BigNumber;
    supplyToken1Decimals: BigNumber;
    borrowToken0Decimals: BigNumber;
    borrowToken1Decimals: BigNumber;
    collateralFactor: number;
    liquidationThreshold: number;
    liquidationMaxLimit: number;
    withdrawalGap: number;
    liquidationPenalty: number;
    borrowFee: number;
    oracle: string;
    oraclePriceOperate: BigNumber;
    oraclePriceLiquidate: BigNumber;
    vaultSupplyExchangePrice: BigNumber;
    vaultBorrowExchangePrice: BigNumber;
    supplyRateVault: BigNumber;
    borrowRateVault: BigNumber;
    rewardsOrFeeRateSupply: BigNumber;
    rewardsOrFeeRateBorrow: BigNumber;
    totalPositions: BigNumber;
    totalSupplyVault: BigNumber;
    totalBorrowVault: BigNumber;
    withdrawalLimit: BigNumber;
    withdrawableUntilLimit: BigNumber;
    withdrawable: BigNumber;
    baseWithdrawalLimit: BigNumber;
    withdrawExpandPercent: BigNumber;
    withdrawExpandDuration: BigNumber;
    borrowLimit: BigNumber;
    borrowableUntilLimit: BigNumber;
    borrowable: BigNumber;
    borrowLimitUtilization: BigNumber;
    maxBorrowLimit: BigNumber;
    borrowExpandPercent: BigNumber;
    borrowExpandDuration: BigNumber;
    baseBorrowLimit: BigNumber;
    minimumBorrowing: BigNumber;
    dexSupplyData: FluidView.DexSupplyDataStructOutput;
    dexBorrowData: FluidView.DexBorrowDataStructOutput;
  };

  export type NftWithVaultStruct = {
    nftId: PromiseOrValue<BigNumberish>;
    vaultId: PromiseOrValue<BigNumberish>;
    vaultAddr: PromiseOrValue<string>;
  };

  export type NftWithVaultStructOutput = [BigNumber, BigNumber, string] & {
    nftId: BigNumber;
    vaultId: BigNumber;
    vaultAddr: string;
  };
}

export interface FluidViewInterface extends utils.Interface {
  functions: {
    "estimateBorrow(address,uint256,uint256,uint256)": FunctionFragment;
    "estimateDeposit(address,uint256,uint256,uint256)": FunctionFragment;
    "estimateDexPositionCollateralInOneToken(uint256,uint256,uint256)": FunctionFragment;
    "estimateDexPositionDebtInOneToken(uint256,uint256,uint256)": FunctionFragment;
    "estimatePayback(address,uint256,uint256,uint256)": FunctionFragment;
    "estimateWithdraw(address,uint256,uint256,uint256)": FunctionFragment;
    "getAllFTokens()": FunctionFragment;
    "getAllFTokensData()": FunctionFragment;
    "getAllUserEarnPositionsWithFTokens(address)": FunctionFragment;
    "getDexShareRates(address)": FunctionFragment;
    "getFTokenData(address)": FunctionFragment;
    "getPositionByNftId(uint256)": FunctionFragment;
    "getRatio(uint256)": FunctionFragment;
    "getUserEarnPosition(address,address)": FunctionFragment;
    "getUserEarnPositionWithFToken(address,address)": FunctionFragment;
    "getUserNftIds(address)": FunctionFragment;
    "getUserNftIdsWithVaultIds(address)": FunctionFragment;
    "getUserPositions(address)": FunctionFragment;
    "getVaultData(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "estimateBorrow"
      | "estimateDeposit"
      | "estimateDexPositionCollateralInOneToken"
      | "estimateDexPositionDebtInOneToken"
      | "estimatePayback"
      | "estimateWithdraw"
      | "getAllFTokens"
      | "getAllFTokensData"
      | "getAllUserEarnPositionsWithFTokens"
      | "getDexShareRates"
      | "getFTokenData"
      | "getPositionByNftId"
      | "getRatio"
      | "getUserEarnPosition"
      | "getUserEarnPositionWithFToken"
      | "getUserNftIds"
      | "getUserNftIdsWithVaultIds"
      | "getUserPositions"
      | "getVaultData"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "estimateBorrow",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateDeposit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateDexPositionCollateralInOneToken",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateDexPositionDebtInOneToken",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimatePayback",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "estimateWithdraw",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllFTokens",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAllFTokensData",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAllUserEarnPositionsWithFTokens",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getDexShareRates",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getFTokenData",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPositionByNftId",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRatio",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserEarnPosition",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserEarnPositionWithFToken",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserNftIds",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserNftIdsWithVaultIds",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserPositions",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVaultData",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "estimateBorrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateDexPositionCollateralInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateDexPositionDebtInOneToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimatePayback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "estimateWithdraw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllFTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllFTokensData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllUserEarnPositionsWithFTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDexShareRates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFTokenData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPositionByNftId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getRatio", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getUserEarnPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserEarnPositionWithFToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserNftIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserNftIdsWithVaultIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserPositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVaultData",
    data: BytesLike
  ): Result;

  events: {};
}

export interface FluidView extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: FluidViewInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    estimateBorrow(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _maxSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimateDeposit(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _minSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimateDexPositionCollateralInOneToken(
      _nftId: PromiseOrValue<BigNumberish>,
      _minToken0AmountToAccept: PromiseOrValue<BigNumberish>,
      _minToken1AmountToAccept: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimateDexPositionDebtInOneToken(
      _nftId: PromiseOrValue<BigNumberish>,
      _maxToken0AmountToPayback: PromiseOrValue<BigNumberish>,
      _maxToken1AmountToPayback: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimatePayback(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _minSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    estimateWithdraw(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _maxSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAllFTokens(overrides?: CallOverrides): Promise<[string[]]>;

    getAllFTokensData(
      overrides?: CallOverrides
    ): Promise<[FluidView.FTokenDataStructOutput[]]>;

    getAllUserEarnPositionsWithFTokens(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        FluidView.UserEarnPositionStructOutput[],
        FluidView.FTokenDataStructOutput[]
      ] & {
        userPositions: FluidView.UserEarnPositionStructOutput[];
        fTokensData: FluidView.FTokenDataStructOutput[];
      }
    >;

    getDexShareRates(
      _vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getFTokenData(
      _fToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [FluidView.FTokenDataStructOutput] & {
        fTokenData: FluidView.FTokenDataStructOutput;
      }
    >;

    getPositionByNftId(
      _nftId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getRatio(
      _nftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { ratio: BigNumber }>;

    getUserEarnPosition(
      _fToken: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[FluidView.UserEarnPositionStructOutput]>;

    getUserEarnPositionWithFToken(
      _fToken: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        FluidView.UserEarnPositionStructOutput,
        FluidView.FTokenDataStructOutput
      ] & {
        userPosition: FluidView.UserEarnPositionStructOutput;
        fTokenData: FluidView.FTokenDataStructOutput;
      }
    >;

    getUserNftIds(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    getUserNftIdsWithVaultIds(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [FluidView.NftWithVaultStructOutput[]] & {
        retVal: FluidView.NftWithVaultStructOutput[];
      }
    >;

    getUserPositions(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getVaultData(
      _vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  estimateBorrow(
    _vault: PromiseOrValue<string>,
    _token0Amount: PromiseOrValue<BigNumberish>,
    _token1Amount: PromiseOrValue<BigNumberish>,
    _maxSharesAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimateDeposit(
    _vault: PromiseOrValue<string>,
    _token0Amount: PromiseOrValue<BigNumberish>,
    _token1Amount: PromiseOrValue<BigNumberish>,
    _minSharesAmount: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimateDexPositionCollateralInOneToken(
    _nftId: PromiseOrValue<BigNumberish>,
    _minToken0AmountToAccept: PromiseOrValue<BigNumberish>,
    _minToken1AmountToAccept: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimateDexPositionDebtInOneToken(
    _nftId: PromiseOrValue<BigNumberish>,
    _maxToken0AmountToPayback: PromiseOrValue<BigNumberish>,
    _maxToken1AmountToPayback: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimatePayback(
    _vault: PromiseOrValue<string>,
    _token0Amount: PromiseOrValue<BigNumberish>,
    _token1Amount: PromiseOrValue<BigNumberish>,
    _minSharesAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  estimateWithdraw(
    _vault: PromiseOrValue<string>,
    _token0Amount: PromiseOrValue<BigNumberish>,
    _token1Amount: PromiseOrValue<BigNumberish>,
    _maxSharesAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAllFTokens(overrides?: CallOverrides): Promise<string[]>;

  getAllFTokensData(
    overrides?: CallOverrides
  ): Promise<FluidView.FTokenDataStructOutput[]>;

  getAllUserEarnPositionsWithFTokens(
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      FluidView.UserEarnPositionStructOutput[],
      FluidView.FTokenDataStructOutput[]
    ] & {
      userPositions: FluidView.UserEarnPositionStructOutput[];
      fTokensData: FluidView.FTokenDataStructOutput[];
    }
  >;

  getDexShareRates(
    _vault: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getFTokenData(
    _fToken: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FluidView.FTokenDataStructOutput>;

  getPositionByNftId(
    _nftId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getRatio(
    _nftId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getUserEarnPosition(
    _fToken: PromiseOrValue<string>,
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FluidView.UserEarnPositionStructOutput>;

  getUserEarnPositionWithFToken(
    _fToken: PromiseOrValue<string>,
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      FluidView.UserEarnPositionStructOutput,
      FluidView.FTokenDataStructOutput
    ] & {
      userPosition: FluidView.UserEarnPositionStructOutput;
      fTokenData: FluidView.FTokenDataStructOutput;
    }
  >;

  getUserNftIds(
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  getUserNftIdsWithVaultIds(
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<FluidView.NftWithVaultStructOutput[]>;

  getUserPositions(
    _user: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getVaultData(
    _vault: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    estimateBorrow(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _maxSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimateDeposit(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _minSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimateDexPositionCollateralInOneToken(
      _nftId: PromiseOrValue<BigNumberish>,
      _minToken0AmountToAccept: PromiseOrValue<BigNumberish>,
      _minToken1AmountToAccept: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimateDexPositionDebtInOneToken(
      _nftId: PromiseOrValue<BigNumberish>,
      _maxToken0AmountToPayback: PromiseOrValue<BigNumberish>,
      _maxToken1AmountToPayback: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimatePayback(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _minSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    estimateWithdraw(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _maxSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllFTokens(overrides?: CallOverrides): Promise<string[]>;

    getAllFTokensData(
      overrides?: CallOverrides
    ): Promise<FluidView.FTokenDataStructOutput[]>;

    getAllUserEarnPositionsWithFTokens(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        FluidView.UserEarnPositionStructOutput[],
        FluidView.FTokenDataStructOutput[]
      ] & {
        userPositions: FluidView.UserEarnPositionStructOutput[];
        fTokensData: FluidView.FTokenDataStructOutput[];
      }
    >;

    getDexShareRates(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber] & {
        token0PerSupplyShare: BigNumber;
        token1PerSupplyShare: BigNumber;
        token0PerBorrowShare: BigNumber;
        token1PerBorrowShare: BigNumber;
      }
    >;

    getFTokenData(
      _fToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FluidView.FTokenDataStructOutput>;

    getPositionByNftId(
      _nftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [FluidView.UserPositionStructOutput, FluidView.VaultDataStructOutput] & {
        position: FluidView.UserPositionStructOutput;
        vault: FluidView.VaultDataStructOutput;
      }
    >;

    getRatio(
      _nftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserEarnPosition(
      _fToken: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FluidView.UserEarnPositionStructOutput>;

    getUserEarnPositionWithFToken(
      _fToken: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        FluidView.UserEarnPositionStructOutput,
        FluidView.FTokenDataStructOutput
      ] & {
        userPosition: FluidView.UserEarnPositionStructOutput;
        fTokenData: FluidView.FTokenDataStructOutput;
      }
    >;

    getUserNftIds(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    getUserNftIdsWithVaultIds(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FluidView.NftWithVaultStructOutput[]>;

    getUserPositions(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        FluidView.UserPositionStructOutput[],
        FluidView.VaultDataStructOutput[]
      ] & {
        positions: FluidView.UserPositionStructOutput[];
        vaults: FluidView.VaultDataStructOutput[];
      }
    >;

    getVaultData(
      _vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<FluidView.VaultDataStructOutput>;
  };

  filters: {};

  estimateGas: {
    estimateBorrow(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _maxSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimateDeposit(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _minSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimateDexPositionCollateralInOneToken(
      _nftId: PromiseOrValue<BigNumberish>,
      _minToken0AmountToAccept: PromiseOrValue<BigNumberish>,
      _minToken1AmountToAccept: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimateDexPositionDebtInOneToken(
      _nftId: PromiseOrValue<BigNumberish>,
      _maxToken0AmountToPayback: PromiseOrValue<BigNumberish>,
      _maxToken1AmountToPayback: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimatePayback(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _minSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    estimateWithdraw(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _maxSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAllFTokens(overrides?: CallOverrides): Promise<BigNumber>;

    getAllFTokensData(overrides?: CallOverrides): Promise<BigNumber>;

    getAllUserEarnPositionsWithFTokens(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDexShareRates(
      _vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getFTokenData(
      _fToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPositionByNftId(
      _nftId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getRatio(
      _nftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserEarnPosition(
      _fToken: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserEarnPositionWithFToken(
      _fToken: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserNftIds(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserNftIdsWithVaultIds(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserPositions(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getVaultData(
      _vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    estimateBorrow(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _maxSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimateDeposit(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _minSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimateDexPositionCollateralInOneToken(
      _nftId: PromiseOrValue<BigNumberish>,
      _minToken0AmountToAccept: PromiseOrValue<BigNumberish>,
      _minToken1AmountToAccept: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimateDexPositionDebtInOneToken(
      _nftId: PromiseOrValue<BigNumberish>,
      _maxToken0AmountToPayback: PromiseOrValue<BigNumberish>,
      _maxToken1AmountToPayback: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimatePayback(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _minSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    estimateWithdraw(
      _vault: PromiseOrValue<string>,
      _token0Amount: PromiseOrValue<BigNumberish>,
      _token1Amount: PromiseOrValue<BigNumberish>,
      _maxSharesAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAllFTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAllFTokensData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAllUserEarnPositionsWithFTokens(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDexShareRates(
      _vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getFTokenData(
      _fToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPositionByNftId(
      _nftId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getRatio(
      _nftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserEarnPosition(
      _fToken: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserEarnPositionWithFToken(
      _fToken: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserNftIds(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserNftIdsWithVaultIds(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserPositions(
      _user: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getVaultData(
      _vault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
