/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface TokenInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "MAX"
      | "_buyDestroyFee"
      | "_buyLiquidityFee"
      | "_buyMarketingFee"
      | "_buyTeamFee"
      | "_isBlacklisted"
      | "_liquidityShare"
      | "_marketingShare"
      | "_maxDestroyAmount"
      | "_maxTxAmount"
      | "_owner"
      | "_sellDestroyFee"
      | "_sellLiquidityFee"
      | "_sellMarketingFee"
      | "_sellTeamFee"
      | "_tFeeTotal"
      | "_teamShare"
      | "_totalDistributionShares"
      | "_totalTaxIfBuying"
      | "_totalTaxIfSelling"
      | "_walletMax"
      | "airdropNumbs"
      | "allowance"
      | "antiSYNC"
      | "approve"
      | "balanceOf"
      | "checkWalletLimit"
      | "deadAddress"
      | "decimals"
      | "decreaseAllowance"
      | "enableDisableWalletLimit"
      | "enableOffTrade"
      | "excludeMultipleAccountsFromFees"
      | "excludeMultipleTxLimit"
      | "first"
      | "getCirculatingSupply"
      | "getTime"
      | "increaseAllowance"
      | "isExcludedFromFee"
      | "isMarketPair"
      | "isTxLimitExempt"
      | "isWalletLimitExempt"
      | "kill"
      | "launch"
      | "marketingWalletAddress"
      | "minimumTokensBeforeSwapAmount"
      | "multipleBotlistAddress"
      | "name"
      | "owner"
      | "setAirdropNumbs"
      | "setAntiSYNCEnable"
      | "setBuyTaxes"
      | "setDistributionSettings"
      | "setIsExcludedFromFee"
      | "setIsTxLimitExempt"
      | "setIsWalletLimitExempt"
      | "setKing"
      | "setMarketPairStatus"
      | "setMarketingWalletAddress"
      | "setMaxDesAmount"
      | "setMaxTxAmount"
      | "setNumTokensBeforeSwap"
      | "setSelTaxes"
      | "setSwapAndLiquifyByLimitOnly"
      | "setSwapAndLiquifyEnabled"
      | "setTeamWalletAddress"
      | "setWalletLimit"
      | "startTradeBlock"
      | "swapAndLiquifyByLimitOnly"
      | "swapAndLiquifyEnabled"
      | "symbol"
      | "teamWalletAddress"
      | "totalSupply"
      | "transfer"
      | "transferFrom"
      | "transferOwnership"
      | "uniswapPair"
      | "uniswapV2Router"
      | "version"
      | "waiveOwnership"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "Approval"
      | "OwnershipTransferred"
      | "SwapAndLiquify"
      | "SwapAndLiquifyEnabledUpdated"
      | "SwapETHForTokens"
      | "SwapTokensForETH"
      | "Transfer"
  ): EventFragment;

  encodeFunctionData(functionFragment: "MAX", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "_buyDestroyFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_buyLiquidityFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_buyMarketingFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_buyTeamFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_isBlacklisted",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "_liquidityShare",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_marketingShare",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_maxDestroyAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_maxTxAmount",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "_owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "_sellDestroyFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_sellLiquidityFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_sellMarketingFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_sellTeamFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_tFeeTotal",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_teamShare",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_totalDistributionShares",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_totalTaxIfBuying",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_totalTaxIfSelling",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "_walletMax",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "airdropNumbs",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "antiSYNC", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "checkWalletLimit",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deadAddress",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "decreaseAllowance",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "enableDisableWalletLimit",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "enableOffTrade",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "excludeMultipleAccountsFromFees",
    values: [AddressLike[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "excludeMultipleTxLimit",
    values: [AddressLike[], boolean]
  ): string;
  encodeFunctionData(functionFragment: "first", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getCirculatingSupply",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getTime", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "increaseAllowance",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isExcludedFromFee",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isMarketPair",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isTxLimitExempt",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isWalletLimitExempt",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "kill", values?: undefined): string;
  encodeFunctionData(functionFragment: "launch", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "marketingWalletAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minimumTokensBeforeSwapAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "multipleBotlistAddress",
    values: [AddressLike[], boolean]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAirdropNumbs",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setAntiSYNCEnable",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setBuyTaxes",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setDistributionSettings",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsExcludedFromFee",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsTxLimitExempt",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsWalletLimitExempt",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setKing",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setMarketPairStatus",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setMarketingWalletAddress",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxDesAmount",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxTxAmount",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setNumTokensBeforeSwap",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setSelTaxes",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setSwapAndLiquifyByLimitOnly",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setSwapAndLiquifyEnabled",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setTeamWalletAddress",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setWalletLimit",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "startTradeBlock",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "swapAndLiquifyByLimitOnly",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "swapAndLiquifyEnabled",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "teamWalletAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapPair",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapV2Router",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "waiveOwnership",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "MAX", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_buyDestroyFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_buyLiquidityFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_buyMarketingFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_buyTeamFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_isBlacklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_liquidityShare",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_marketingShare",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_maxDestroyAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_maxTxAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_sellDestroyFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_sellLiquidityFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_sellMarketingFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_sellTeamFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_tFeeTotal", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "_teamShare", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "_totalDistributionShares",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_totalTaxIfBuying",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "_totalTaxIfSelling",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_walletMax", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "airdropNumbs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "antiSYNC", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "checkWalletLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deadAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "decreaseAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableDisableWalletLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableOffTrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "excludeMultipleAccountsFromFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "excludeMultipleTxLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "first", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCirculatingSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getTime", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "increaseAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isExcludedFromFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isMarketPair",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTxLimitExempt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isWalletLimitExempt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "kill", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "launch", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "marketingWalletAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minimumTokensBeforeSwapAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "multipleBotlistAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAirdropNumbs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAntiSYNCEnable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBuyTaxes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDistributionSettings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsExcludedFromFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsTxLimitExempt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsWalletLimitExempt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setKing", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setMarketPairStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMarketingWalletAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxDesAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxTxAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setNumTokensBeforeSwap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSelTaxes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSwapAndLiquifyByLimitOnly",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSwapAndLiquifyEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTeamWalletAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setWalletLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startTradeBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapAndLiquifyByLimitOnly",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapAndLiquifyEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "teamWalletAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapPair",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapV2Router",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "waiveOwnership",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    spender: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [owner: string, spender: string, value: bigint];
  export interface OutputObject {
    owner: string;
    spender: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapAndLiquifyEvent {
  export type InputTuple = [
    tokensSwapped: BigNumberish,
    ethReceived: BigNumberish,
    tokensIntoLiqudity: BigNumberish
  ];
  export type OutputTuple = [
    tokensSwapped: bigint,
    ethReceived: bigint,
    tokensIntoLiqudity: bigint
  ];
  export interface OutputObject {
    tokensSwapped: bigint;
    ethReceived: bigint;
    tokensIntoLiqudity: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapAndLiquifyEnabledUpdatedEvent {
  export type InputTuple = [enabled: boolean];
  export type OutputTuple = [enabled: boolean];
  export interface OutputObject {
    enabled: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapETHForTokensEvent {
  export type InputTuple = [amountIn: BigNumberish, path: AddressLike[]];
  export type OutputTuple = [amountIn: bigint, path: string[]];
  export interface OutputObject {
    amountIn: bigint;
    path: string[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SwapTokensForETHEvent {
  export type InputTuple = [amountIn: BigNumberish, path: AddressLike[]];
  export type OutputTuple = [amountIn: bigint, path: string[]];
  export interface OutputObject {
    amountIn: bigint;
    path: string[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, value: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Token extends BaseContract {
  connect(runner?: ContractRunner | null): Token;
  waitForDeployment(): Promise<this>;

  interface: TokenInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  MAX: TypedContractMethod<[], [bigint], "view">;

  _buyDestroyFee: TypedContractMethod<[], [bigint], "view">;

  _buyLiquidityFee: TypedContractMethod<[], [bigint], "view">;

  _buyMarketingFee: TypedContractMethod<[], [bigint], "view">;

  _buyTeamFee: TypedContractMethod<[], [bigint], "view">;

  _isBlacklisted: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  _liquidityShare: TypedContractMethod<[], [bigint], "view">;

  _marketingShare: TypedContractMethod<[], [bigint], "view">;

  _maxDestroyAmount: TypedContractMethod<[], [bigint], "view">;

  _maxTxAmount: TypedContractMethod<[], [bigint], "view">;

  _owner: TypedContractMethod<[], [string], "view">;

  _sellDestroyFee: TypedContractMethod<[], [bigint], "view">;

  _sellLiquidityFee: TypedContractMethod<[], [bigint], "view">;

  _sellMarketingFee: TypedContractMethod<[], [bigint], "view">;

  _sellTeamFee: TypedContractMethod<[], [bigint], "view">;

  _tFeeTotal: TypedContractMethod<[], [bigint], "view">;

  _teamShare: TypedContractMethod<[], [bigint], "view">;

  _totalDistributionShares: TypedContractMethod<[], [bigint], "view">;

  _totalTaxIfBuying: TypedContractMethod<[], [bigint], "view">;

  _totalTaxIfSelling: TypedContractMethod<[], [bigint], "view">;

  _walletMax: TypedContractMethod<[], [bigint], "view">;

  airdropNumbs: TypedContractMethod<[], [bigint], "view">;

  allowance: TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;

  antiSYNC: TypedContractMethod<[], [boolean], "view">;

  approve: TypedContractMethod<
    [spender: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[account: AddressLike], [bigint], "view">;

  checkWalletLimit: TypedContractMethod<[], [boolean], "view">;

  deadAddress: TypedContractMethod<[], [string], "view">;

  decimals: TypedContractMethod<[], [bigint], "view">;

  decreaseAllowance: TypedContractMethod<
    [spender: AddressLike, subtractedValue: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  enableDisableWalletLimit: TypedContractMethod<
    [newValue: boolean],
    [void],
    "nonpayable"
  >;

  enableOffTrade: TypedContractMethod<[], [boolean], "view">;

  excludeMultipleAccountsFromFees: TypedContractMethod<
    [accounts: AddressLike[], excluded: boolean],
    [void],
    "nonpayable"
  >;

  excludeMultipleTxLimit: TypedContractMethod<
    [accounts: AddressLike[], excluded: boolean],
    [void],
    "nonpayable"
  >;

  first: TypedContractMethod<[], [bigint], "view">;

  getCirculatingSupply: TypedContractMethod<[], [bigint], "view">;

  getTime: TypedContractMethod<[], [bigint], "view">;

  increaseAllowance: TypedContractMethod<
    [spender: AddressLike, addedValue: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  isExcludedFromFee: TypedContractMethod<
    [arg0: AddressLike],
    [boolean],
    "view"
  >;

  isMarketPair: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  isTxLimitExempt: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  isWalletLimitExempt: TypedContractMethod<
    [arg0: AddressLike],
    [boolean],
    "view"
  >;

  kill: TypedContractMethod<[], [bigint], "view">;

  launch: TypedContractMethod<[], [void], "nonpayable">;

  marketingWalletAddress: TypedContractMethod<[], [string], "view">;

  minimumTokensBeforeSwapAmount: TypedContractMethod<[], [bigint], "view">;

  multipleBotlistAddress: TypedContractMethod<
    [accounts: AddressLike[], excluded: boolean],
    [void],
    "nonpayable"
  >;

  name: TypedContractMethod<[], [string], "view">;

  owner: TypedContractMethod<[], [string], "view">;

  setAirdropNumbs: TypedContractMethod<
    [newValue: BigNumberish],
    [void],
    "nonpayable"
  >;

  setAntiSYNCEnable: TypedContractMethod<[s: boolean], [void], "nonpayable">;

  setBuyTaxes: TypedContractMethod<
    [
      newLiquidityTax: BigNumberish,
      newMarketingTax: BigNumberish,
      newTeamTax: BigNumberish,
      newDestroyTax: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  setDistributionSettings: TypedContractMethod<
    [
      newLiquidityShare: BigNumberish,
      newMarketingShare: BigNumberish,
      newTeamShare: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  setIsExcludedFromFee: TypedContractMethod<
    [account: AddressLike, newValue: boolean],
    [void],
    "nonpayable"
  >;

  setIsTxLimitExempt: TypedContractMethod<
    [holder: AddressLike, exempt: boolean],
    [void],
    "nonpayable"
  >;

  setIsWalletLimitExempt: TypedContractMethod<
    [holder: AddressLike, exempt: boolean],
    [void],
    "nonpayable"
  >;

  setKing: TypedContractMethod<[newValue: BigNumberish], [void], "nonpayable">;

  setMarketPairStatus: TypedContractMethod<
    [account: AddressLike, newValue: boolean],
    [void],
    "nonpayable"
  >;

  setMarketingWalletAddress: TypedContractMethod<
    [newAddress: AddressLike],
    [void],
    "nonpayable"
  >;

  setMaxDesAmount: TypedContractMethod<
    [maxDestroy: BigNumberish],
    [void],
    "nonpayable"
  >;

  setMaxTxAmount: TypedContractMethod<
    [maxTxAmount: BigNumberish],
    [void],
    "nonpayable"
  >;

  setNumTokensBeforeSwap: TypedContractMethod<
    [newLimit: BigNumberish],
    [void],
    "nonpayable"
  >;

  setSelTaxes: TypedContractMethod<
    [
      newLiquidityTax: BigNumberish,
      newMarketingTax: BigNumberish,
      newTeamTax: BigNumberish,
      newDestroyTax: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  setSwapAndLiquifyByLimitOnly: TypedContractMethod<
    [newValue: boolean],
    [void],
    "nonpayable"
  >;

  setSwapAndLiquifyEnabled: TypedContractMethod<
    [_enabled: boolean],
    [void],
    "nonpayable"
  >;

  setTeamWalletAddress: TypedContractMethod<
    [newAddress: AddressLike],
    [void],
    "nonpayable"
  >;

  setWalletLimit: TypedContractMethod<
    [newLimit: BigNumberish],
    [void],
    "nonpayable"
  >;

  startTradeBlock: TypedContractMethod<[], [bigint], "view">;

  swapAndLiquifyByLimitOnly: TypedContractMethod<[], [boolean], "view">;

  swapAndLiquifyEnabled: TypedContractMethod<[], [boolean], "view">;

  symbol: TypedContractMethod<[], [string], "view">;

  teamWalletAddress: TypedContractMethod<[], [string], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  transfer: TypedContractMethod<
    [recipient: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [sender: AddressLike, recipient: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  uniswapPair: TypedContractMethod<[], [string], "view">;

  uniswapV2Router: TypedContractMethod<[], [string], "view">;

  version: TypedContractMethod<[], [bigint], "view">;

  waiveOwnership: TypedContractMethod<[], [void], "nonpayable">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "MAX"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_buyDestroyFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_buyLiquidityFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_buyMarketingFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_buyTeamFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_isBlacklisted"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "_liquidityShare"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_marketingShare"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_maxDestroyAmount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_maxTxAmount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "_sellDestroyFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_sellLiquidityFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_sellMarketingFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_sellTeamFee"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_tFeeTotal"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_teamShare"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_totalDistributionShares"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_totalTaxIfBuying"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_totalTaxIfSelling"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "_walletMax"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "airdropNumbs"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "antiSYNC"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [spender: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[account: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "checkWalletLimit"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "deadAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "decimals"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "decreaseAllowance"
  ): TypedContractMethod<
    [spender: AddressLike, subtractedValue: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "enableDisableWalletLimit"
  ): TypedContractMethod<[newValue: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "enableOffTrade"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "excludeMultipleAccountsFromFees"
  ): TypedContractMethod<
    [accounts: AddressLike[], excluded: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "excludeMultipleTxLimit"
  ): TypedContractMethod<
    [accounts: AddressLike[], excluded: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "first"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getCirculatingSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getTime"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "increaseAllowance"
  ): TypedContractMethod<
    [spender: AddressLike, addedValue: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "isExcludedFromFee"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isMarketPair"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isTxLimitExempt"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isWalletLimitExempt"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "kill"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "launch"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "marketingWalletAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "minimumTokensBeforeSwapAmount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "multipleBotlistAddress"
  ): TypedContractMethod<
    [accounts: AddressLike[], excluded: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "setAirdropNumbs"
  ): TypedContractMethod<[newValue: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setAntiSYNCEnable"
  ): TypedContractMethod<[s: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setBuyTaxes"
  ): TypedContractMethod<
    [
      newLiquidityTax: BigNumberish,
      newMarketingTax: BigNumberish,
      newTeamTax: BigNumberish,
      newDestroyTax: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setDistributionSettings"
  ): TypedContractMethod<
    [
      newLiquidityShare: BigNumberish,
      newMarketingShare: BigNumberish,
      newTeamShare: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setIsExcludedFromFee"
  ): TypedContractMethod<
    [account: AddressLike, newValue: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setIsTxLimitExempt"
  ): TypedContractMethod<
    [holder: AddressLike, exempt: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setIsWalletLimitExempt"
  ): TypedContractMethod<
    [holder: AddressLike, exempt: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setKing"
  ): TypedContractMethod<[newValue: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setMarketPairStatus"
  ): TypedContractMethod<
    [account: AddressLike, newValue: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setMarketingWalletAddress"
  ): TypedContractMethod<[newAddress: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setMaxDesAmount"
  ): TypedContractMethod<[maxDestroy: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setMaxTxAmount"
  ): TypedContractMethod<[maxTxAmount: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setNumTokensBeforeSwap"
  ): TypedContractMethod<[newLimit: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setSelTaxes"
  ): TypedContractMethod<
    [
      newLiquidityTax: BigNumberish,
      newMarketingTax: BigNumberish,
      newTeamTax: BigNumberish,
      newDestroyTax: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setSwapAndLiquifyByLimitOnly"
  ): TypedContractMethod<[newValue: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setSwapAndLiquifyEnabled"
  ): TypedContractMethod<[_enabled: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setTeamWalletAddress"
  ): TypedContractMethod<[newAddress: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setWalletLimit"
  ): TypedContractMethod<[newLimit: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "startTradeBlock"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "swapAndLiquifyByLimitOnly"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "swapAndLiquifyEnabled"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "teamWalletAddress"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transfer"
  ): TypedContractMethod<
    [recipient: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [sender: AddressLike, recipient: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "uniswapPair"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "uniswapV2Router"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "version"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "waiveOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "SwapAndLiquify"
  ): TypedContractEvent<
    SwapAndLiquifyEvent.InputTuple,
    SwapAndLiquifyEvent.OutputTuple,
    SwapAndLiquifyEvent.OutputObject
  >;
  getEvent(
    key: "SwapAndLiquifyEnabledUpdated"
  ): TypedContractEvent<
    SwapAndLiquifyEnabledUpdatedEvent.InputTuple,
    SwapAndLiquifyEnabledUpdatedEvent.OutputTuple,
    SwapAndLiquifyEnabledUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "SwapETHForTokens"
  ): TypedContractEvent<
    SwapETHForTokensEvent.InputTuple,
    SwapETHForTokensEvent.OutputTuple,
    SwapETHForTokensEvent.OutputObject
  >;
  getEvent(
    key: "SwapTokensForETH"
  ): TypedContractEvent<
    SwapTokensForETHEvent.InputTuple,
    SwapTokensForETHEvent.OutputTuple,
    SwapTokensForETHEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "SwapAndLiquify(uint256,uint256,uint256)": TypedContractEvent<
      SwapAndLiquifyEvent.InputTuple,
      SwapAndLiquifyEvent.OutputTuple,
      SwapAndLiquifyEvent.OutputObject
    >;
    SwapAndLiquify: TypedContractEvent<
      SwapAndLiquifyEvent.InputTuple,
      SwapAndLiquifyEvent.OutputTuple,
      SwapAndLiquifyEvent.OutputObject
    >;

    "SwapAndLiquifyEnabledUpdated(bool)": TypedContractEvent<
      SwapAndLiquifyEnabledUpdatedEvent.InputTuple,
      SwapAndLiquifyEnabledUpdatedEvent.OutputTuple,
      SwapAndLiquifyEnabledUpdatedEvent.OutputObject
    >;
    SwapAndLiquifyEnabledUpdated: TypedContractEvent<
      SwapAndLiquifyEnabledUpdatedEvent.InputTuple,
      SwapAndLiquifyEnabledUpdatedEvent.OutputTuple,
      SwapAndLiquifyEnabledUpdatedEvent.OutputObject
    >;

    "SwapETHForTokens(uint256,address[])": TypedContractEvent<
      SwapETHForTokensEvent.InputTuple,
      SwapETHForTokensEvent.OutputTuple,
      SwapETHForTokensEvent.OutputObject
    >;
    SwapETHForTokens: TypedContractEvent<
      SwapETHForTokensEvent.InputTuple,
      SwapETHForTokensEvent.OutputTuple,
      SwapETHForTokensEvent.OutputObject
    >;

    "SwapTokensForETH(uint256,address[])": TypedContractEvent<
      SwapTokensForETHEvent.InputTuple,
      SwapTokensForETHEvent.OutputTuple,
      SwapTokensForETHEvent.OutputObject
    >;
    SwapTokensForETH: TypedContractEvent<
      SwapTokensForETHEvent.InputTuple,
      SwapTokensForETHEvent.OutputTuple,
      SwapTokensForETHEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
  };
}
