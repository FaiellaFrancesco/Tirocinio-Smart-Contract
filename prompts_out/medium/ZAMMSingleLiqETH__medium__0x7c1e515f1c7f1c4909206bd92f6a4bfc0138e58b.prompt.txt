You are an expert blockchain developer specialized in writing professional and reliable test suites for Solidity smart contracts using Hardhat, Mocha, and Chai.

### Goal:
Generate a complete TypeScript test suite for the provided Solidity smart contract.

### SCAFFOLD:
import { expect } from "chai";
  import hre from "hardhat";
  import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

  /**
   * Scaffold automatically generated for contracts/medium/0x7c1e515f1c7f1c4909206bd92f6a4bfc0138e58b.sol:ZAMMSingleLiqETH.
   * Blocks marked // TODO_AI must be completed by the LLM.
   */

  describe("contracts/medium/0x7c1e515f1c7f1c4909206bd92f6a4bfc0138e58b.sol:ZAMMSingleLiqETH — LLM Scaffold", function () {
    async function deployFixture() {
      const { ethers } = (await import("hardhat")).default;
      const [owner, addr1, addr2] = await ethers.getSigners();
      const Factory = await ethers.getContractFactory("ZAMMSingleLiqETH");
      // TODO_AI: complete constructor parameters if present
      const contract = await Factory.deploy();
      await contract.waitForDeployment();
      return { contract, owner, addr1, addr2 };
    }

    it("basic deployment", async function () {
      const { contract } = await loadFixture(deployFixture);
      expect(await contract.getAddress()).to.match(/^0x[a-fA-F0-9]{40}$/);
    });

    // Events in ABI: —

    
  describe("addSingleLiqETH(tuple,uint256,uint256,uint256,address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.addSingleLiqETH({ /* TODO_AI tuple */ }, 1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */, addr1.address /* TODO_AI */, 1n /* TODO_AI */, { value: 1n /* TODO_AI in wei */ });
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.addSingleLiqETH({ /* TODO_AI invalid tuple */ }, 0n /* TODO_AI: make invalid/edge */, 0n /* TODO_AI: make invalid/edge */, 0n /* TODO_AI: make invalid/edge */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.revertedWith(/* TODO_AI: inserire messaggio */);
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });

  });


### Contract:
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

address constant ZAMM = 0x00000000000008882D72EfA6cCE4B6a40b24C860;

struct PoolKey {
    uint256 id0;
    uint256 id1;
    address token0;
    address token1;
    uint96 swapFee;
}

interface IZAMM {
    function addLiquidity(
        PoolKey calldata poolKey,
        uint256 amount0Desired,
        uint256 amount1Desired,
        uint256 amount0Min,
        uint256 amount1Min,
        address to,
        uint256 deadline
    ) external payable returns (uint256 amount0, uint256 amount1, uint256 liquidity);
    
    function swapExactIn(
        PoolKey calldata poolKey,
        uint256 amountIn,
        uint256 amountOutMin,
        bool zeroForOne,
        address to,
        uint256 deadline
    ) external payable returns (uint256 amountOut);
    
    function recoverTransientBalance(address token, uint256 id, address to) external returns (uint256 amount);
}

contract ZAMMSingleLiqETH {
    error InvalidPoolKey();

    function addSingleLiqETH(
        PoolKey calldata poolKey,
        uint256 amountOutMin,  
        uint256 amount0Min,    
        uint256 amount1Min,    
        address to,
        uint256 deadline
    ) public payable returns (uint256 amount0, uint256 amount1, uint256 liquidity) {
        unchecked {
            require(poolKey.token0 == address(0), InvalidPoolKey());
            
            assembly ("memory-safe") {
                pop(call(gas(), ZAMM, callvalue(), codesize(), 0x00, codesize(), 0x00))
            }
            
            uint256 halfETH = msg.value / 2;
            
            uint256 token1Amount = IZAMM(ZAMM).swapExactIn(
                poolKey,
                halfETH,
                amountOutMin,
                true, 
                ZAMM,
                deadline
            );
            
            (amount0, amount1, liquidity) = IZAMM(ZAMM).addLiquidity(
                poolKey,
                halfETH,  
                token1Amount,         
                amount0Min,           
                amount1Min,           
                to,                   
                deadline
            );
            
            IZAMM(ZAMM).recoverTransientBalance(address(0), 0, msg.sender);
            IZAMM(ZAMM).recoverTransientBalance(poolKey.token1, poolKey.id1, msg.sender);
        }
    }
}


-### Instructions:
- Use **ethers.js v5** and **Chai** for testing.
- Import ethers from "ethers".

  - **Deployment**: Verify correct initialization and constructor state.
  - **Happy paths**: Normal usage for every public or external function.
  - **Reverts**: Test invalid inputs, unauthorized access, and failure conditions.
  - **Events**: Verify that events are emitted with correct parameters using `.to.emit()`.
  - **Edge cases**: Test cases like zero values, address(0), max integers, empty strings, etc.


### Output:
Your output should include **only valid, executable TypeScript test code** (`.spec.ts` format). The code should be complete and ready to execute with Hardhat.

### Test Requirements:
- Use **ethers.js v5** (specifically `ethers.utils` and `ethers.constants`).
- Ensure all test functions are structured clearly:
  - **State-modifying functions**: Test changes to contract state.
  - **Getter and setter functions**: Ensure getters return the correct value and setters correctly modify state.
  - **Pure and view functions**: Ensure that state is not modified and the correct values are returned.
  - **Access control functions**: Verify that only authorized accounts (e.g., owner, specific roles) can call functions with appropriate access control.
  - **Event emission**: Verify the correct emission of events with proper arguments, using `.to.emit()`.
  - **Error handling**: Ensure functions revert with appropriate error messages on invalid inputs.
  - **Edge cases**: Handle boundary conditions, such as `address(0)`, maximum integers, and empty strings.

---

### Example Test:

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";

describe("ContractName", function () {
  it("should return the correct owner", async function () {
    const [owner, addr1] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();
    
    expect(await contract.owner()).to.equal(owner.address);
  });

  it("should revert on invalid address", async function () {
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();

    await expect(
      contract.airdrop("0x0000000000000000000000000000000000000000", 1)
    ).to.be.revertedWith("Invalid address");
  });
});