You are an expert blockchain developer specialized in writing professional and reliable test suites for Solidity smart contracts using Hardhat, Mocha, and Chai.

### Goal:
Generate a complete TypeScript test suite for the provided Solidity smart contract.

### SCAFFOLD:
import { expect } from "chai";
  import hre from "hardhat";
  import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

  /**
   * Scaffold automatically generated for contracts/medium/0x66057a6b2503c7d7d7d39606729e8312e931c96e.sol:ChadGPT.
   * Blocks marked // TODO_AI must be completed by the LLM.
   */

  describe("contracts/medium/0x66057a6b2503c7d7d7d39606729e8312e931c96e.sol:ChadGPT â€” LLM Scaffold", function () {
    async function deployFixture() {
      const { ethers } = (await import("hardhat")).default;
      const [owner, addr1, addr2] = await ethers.getSigners();
      const Factory = await ethers.getContractFactory("ChadGPT");
      // TODO_AI: complete constructor parameters if present
      const contract = await Factory.deploy();
      await contract.waitForDeployment();
      return { contract, owner, addr1, addr2 };
    }

    it("basic deployment", async function () {
      const { contract } = await loadFixture(deployFixture);
      expect(await contract.getAddress()).to.match(/^0x[a-fA-F0-9]{40}$/);
    });

    // Events in ABI: E1, E2

    
  describe("A1(address,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.A1(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.A1(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("B1(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.B1(addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.B1(addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("D1()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.D1();
      // TODO_AI: expect(await contract.D1()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("N1()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.N1();
      // TODO_AI: expect(await contract.N1()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("S1()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.S1();
      // TODO_AI: expect(await contract.S1()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("T1()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.T1();
      // TODO_AI: expect(await contract.T1()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("T2(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.T2(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.T2("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.revertedWith(/* TODO_AI: inserire messaggio */);
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("T3(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.T3(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.T3("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.revertedWith(/* TODO_AI: inserire messaggio */);
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("T4(address,address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.T4(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.T4("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.revertedWith(/* TODO_AI: inserire messaggio */);
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("d()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.d();
      // TODO_AI: expect(await contract.d()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("decreaseA(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.decreaseA(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.decreaseA("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.revertedWith(/* TODO_AI: inserire messaggio */);
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("e()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.e();
      // TODO_AI: expect(await contract.e()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("increaseA(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.increaseA(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.increaseA("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.revertedWith(/* TODO_AI: inserire messaggio */);
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("v()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.v();
      // TODO_AI: expect(await contract.v()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });

  });


### Contract:
// SPDX-License-Identifier: MIT
pragma solidity =0.8.19;
pragma abicoder v2;

abstract contract X {
    function F1() internal view virtual returns (address) {
        return msg.sender;
    }

    function F2() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface I1 {
    event E1(address indexed A, address indexed B, uint256 C);
    event E2(address indexed D, address indexed E, uint256 F);

    function T1() external view returns (uint256);
    function B1(address G) external view returns (uint256);
    function T2(address H, uint256 I) external returns (bool);
    function A1(address J, address K) external view returns (uint256);
    function T3(address L, uint256 M) external returns (bool);
    function T4(address N, address O, uint256 P) external returns (bool);
}

interface I2 is I1 {
    function N1() external view returns (string memory);
    function S1() external view returns (string memory);
    function D1() external view returns (uint8);
}

contract BaseToken is X, I1, I2 {
    mapping(address => uint256) private _b;
    mapping(address => mapping(address => uint256)) private _a;
    uint256 private _s;
    string private _n;
    string private _y;

    constructor(string memory Q, string memory R) {
        _n = Q;
        _y = R;
    }

    function N1() public view virtual override returns (string memory) {
        return _n;
    }

    function S1() public view virtual override returns (string memory) {
        return _y;
    }

    function D1() public view virtual override returns (uint8) {
        return 18;
    }

    function T1() public view virtual override returns (uint256) {
        return _s;
    }

    function B1(address Z) public view virtual override returns (uint256) {
        return _b[Z];
    }

    function T2(address aa, uint256 ab) public virtual override returns (bool) {
        address ac = F1();
        _internalT(ac, aa, ab);
        return true;
    }

    function A1(address ad, address ae) public view virtual override returns (uint256) {
        return _a[ad][ae];
    }

    function T3(address af, uint256 ag) public virtual override returns (bool) {
        address ah = F1();
        _internalA(ah, af, ag);
        return true;
    }

    function T4(address ai, address aj, uint256 ak) public virtual override returns (bool) {
        address al = F1();
        _useA(ai, al, ak);
        _internalT(ai, aj, ak);
        return true;
    }

    function increaseA(address am, uint256 an) public virtual returns (bool) {
        address ao = F1();
        _internalA(ao, am, A1(ao, am) + an);
        return true;
    }

    function decreaseA(address ap, uint256 aq) public virtual returns (bool) {
        address ar = F1();
        uint256 arAllow = A1(ar, ap);
        require(arAllow >= aq, "DEC_A");
        unchecked {
            _internalA(ar, ap, arAllow - aq);
        }
        return true;
    }

    function _internalT(address as_, address at, uint256 au) internal virtual {
        require(as_ != address(0), "TX_FROM_ZERO");
        require(at != address(0), "TX_TO_ZERO");

        _beforeTx(as_, at, au);

        uint256 av = _b[as_];
        require(av >= au, "INSUFFICIENT_BALANCE");
        unchecked {
            _b[as_] = av - au;
            _b[at] += au;
        }

        emit E1(as_, at, au);
        _afterTx(as_, at, au);
    }

    function _mintInternal(address aw, uint256 ax) internal virtual {
        require(aw != address(0), "MINT_ZERO");

        _beforeTx(address(0), aw, ax);

        _s += ax;
        unchecked {
            _b[aw] += ax;
        }

        emit E1(address(0), aw, ax);
        _afterTx(address(0), aw, ax);
    }

    function _burnInternal(address ay, uint256 az) internal virtual {
        require(ay != address(0), "BURN_ZERO");

        _beforeTx(ay, address(0), az);

        uint256 ba = _b[ay];
        require(ba >= az, "BURN_OVER");
        unchecked {
            _b[ay] = ba - az;
            _s -= az;
        }

        emit E1(ay, address(0), az);
        _afterTx(ay, address(0), az);
    }

    function _internalA(address bb, address bc, uint256 bd) internal virtual {
        require(bb != address(0), "APPROVE_ZERO_OWNER");
        require(bc != address(0), "APPROVE_ZERO_SPENDER");

        _a[bb][bc] = bd;
        emit E2(bb, bc, bd);
    }

    function _useA(address be, address bf, uint256 bg) internal virtual {
        uint256 bh = A1(be, bf);
        if (bh != type(uint256).max) {
            require(bh >= bg, "ALLOWANCE_LOW");
            unchecked {
                _internalA(be, bf, bh - bg);
            }
        }
    }

    function _beforeTx(address bi, address bj, uint256 bk) internal virtual {}
    function _afterTx(address bl, address bm, uint256 bn) internal virtual {}
}

contract ChadGPT is BaseToken {
    string public constant v = "4";
    string public constant d = "Z9";
    string public constant e = "ChadGPT";

    uint private constant limit = 100_000_000_000 ether;

    constructor() BaseToken("ChadGPT", "CGPT") {
        _mintInternal(msg.sender, limit);
    }
}


-### Instructions:
- Use **ethers.js v5** and **Chai** for testing.
- Import ethers from "ethers".

  - **Deployment**: Verify correct initialization and constructor state.
  - **Happy paths**: Normal usage for every public or external function.
  - **Reverts**: Test invalid inputs, unauthorized access, and failure conditions.
  - **Events**: Verify that events are emitted with correct parameters using `.to.emit()`.
  - **Edge cases**: Test cases like zero values, address(0), max integers, empty strings, etc.


### Output:
Your output should include **only valid, executable TypeScript test code** (`.spec.ts` format). The code should be complete and ready to execute with Hardhat.

### Test Requirements:
- Use **ethers.js v5** (specifically `ethers.utils` and `ethers.constants`).
- Ensure all test functions are structured clearly:
  - **State-modifying functions**: Test changes to contract state.
  - **Getter and setter functions**: Ensure getters return the correct value and setters correctly modify state.
  - **Pure and view functions**: Ensure that state is not modified and the correct values are returned.
  - **Access control functions**: Verify that only authorized accounts (e.g., owner, specific roles) can call functions with appropriate access control.
  - **Event emission**: Verify the correct emission of events with proper arguments, using `.to.emit()`.
  - **Error handling**: Ensure functions revert with appropriate error messages on invalid inputs.
  - **Edge cases**: Handle boundary conditions, such as `address(0)`, maximum integers, and empty strings.

---

### Example Test:

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";

describe("ContractName", function () {
  it("should return the correct owner", async function () {
    const [owner, addr1] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();
    
    expect(await contract.owner()).to.equal(owner.address);
  });

  it("should revert on invalid address", async function () {
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();

    await expect(
      contract.airdrop("0x0000000000000000000000000000000000000000", 1)
    ).to.be.revertedWith("Invalid address");
  });
});