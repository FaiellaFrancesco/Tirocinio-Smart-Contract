You are an expert blockchain developer specialized in writing professional and reliable test suites for Solidity smart contracts using Hardhat, Mocha, and Chai.

### Goal:
Write a complete TypeScript test suite for the following Solidity smart contract.

### Contract:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract CyberQuoreCoin {
    string public constant name = "CyberQuoreCoin";
    string public constant symbol = "CQC";
    uint8 public constant decimals = 18;
    uint256 public constant totalSupply = 43_000_000_000_000 * 10**18;

    address public owner;
    address public constant charityWallet = 0x39D2C31919B061db9402bdFA803b91D3E5980366;
    address public constant cyberWallet = 0x4F01125B9ADa1006139E2aBAaf0aAEbe6354A8D9;
    address public constant liquidityWallet = 0x26139af27d5C39f8261eF8E2606817D6E06D09B3;
    address public constant mainTokenWallet = 0xB4822154Da4C2a307d8eE0253075b93b6d85b116;
    address public constant marketingWallet = 0x1234567890123456789012345678901234567890;
    address public constant teamWallet = 0x0987654321098765432109876543210987654321;
    address public constant BURN_ADDRESS = address(0xdead);

    uint256 public taxReflection = 80;     // 0.8%
    uint256 public taxCharity = 100;       // 1%
    uint256 public taxCyber = 100;         // 1%
    uint256 public taxLiquidity = 150;     // 1.5%
    uint256 public taxBurn = 9;            // 0.09%
    uint256 private constant FEE_DENOMINATOR = 10000;

    uint256 public maxWalletLimit = totalSupply * 3 / 100; // 3%
    bool public tradingOpen = false;
    uint256 public totalBurned;

    uint256 public unlockTime = 1763779200; // 22 Nov 2025

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => bool) public isBlacklisted;
    mapping(address => bool) public isExcludedFromFees;
    mapping(address => bool) public isExcludedFromLimits;
    mapping(address => uint256) private lastTxBlock;

    address[] public holders;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor() {
        owner = msg.sender;
        balanceOf[mainTokenWallet] = totalSupply;

        isExcludedFromFees[owner] = true;
        isExcludedFromLimits[owner] = true;

        isExcludedFromFees[charityWallet] = true;
        isExcludedFromLimits[charityWallet] = true;
        isExcludedFromFees[cyberWallet] = true;
        isExcludedFromLimits[cyberWallet] = true;
        isExcludedFromFees[liquidityWallet] = true;
        isExcludedFromLimits[liquidityWallet] = true;
        isExcludedFromFees[BURN_ADDRESS] = true;
        isExcludedFromLimits[BURN_ADDRESS] = true;
        isExcludedFromLimits[mainTokenWallet] = true;

        emit Transfer(address(0), mainTokenWallet, totalSupply);
    }

    function openTrading() external onlyOwner {
        tradingOpen = true;
    }

    function blacklist(address account, bool value) external onlyOwner {
        isBlacklisted[account] = value;
    }

    function updateFees(uint256 _reflection, uint256 _charity, uint256 _cyber, uint256 _liquidity, uint256 _burn) external onlyOwner {
        require(_reflection + _charity + _cyber + _liquidity + _burn <= 350, "Total tax too high");
        taxReflection = _reflection;
        taxCharity = _charity;
        taxCyber = _cyber;
        taxLiquidity = _liquidity;
        taxBurn = _burn;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(allowance[from][msg.sender] >= amount, "Allowance exceeded");
        allowance[from][msg.sender] -= amount;
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(from != address(0) && to != address(0), "Zero address");
        require(balanceOf[from] >= amount, "Insufficient balance");
        require(!isBlacklisted[from] && !isBlacklisted[to], "Blacklisted");

        if (!tradingOpen) {
            require(isExcludedFromFees[from] || isExcludedFromFees[to], "Trading not open");
        }

        if (!isExcludedFromLimits[to]) {
            require(balanceOf[to] + amount <= maxWalletLimit, "Exceeds max wallet limit");
        }

        if (lastTxBlock[msg.sender] == block.number) {
            require(isExcludedFromFees[msg.sender], "Only 1 tx per block");
        }
        lastTxBlock[msg.sender] = block.number;

        // Lock marketing/team wallets
        if (from == marketingWallet || from == teamWallet) {
            require(block.timestamp >= unlockTime, "Wallet is locked");
        }

        uint256 taxedAmount = amount;
        if (!isExcludedFromFees[from] && !isExcludedFromFees[to]) {
            uint256 totalTax = taxReflection + taxCharity + taxCyber + taxLiquidity + taxBurn;
            uint256 tax = amount * totalTax / FEE_DENOMINATOR;
            taxedAmount = amount - tax;

            balanceOf[BURN_ADDRESS] += (amount * taxBurn / FEE_DENOMINATOR);
            totalBurned += (amount * taxBurn / FEE_DENOMINATOR);
            emit Transfer(from, BURN_ADDRESS, amount * taxBurn / FEE_DENOMINATOR);

            balanceOf[charityWallet] += (amount * taxCharity / FEE_DENOMINATOR);
            emit Transfer(from, charityWallet, amount * taxCharity / FEE_DENOMINATOR);

            balanceOf[cyberWallet] += (amount * taxCyber / FEE_DENOMINATOR);
            emit Transfer(from, cyberWallet, amount * taxCyber / FEE_DENOMINATOR);

            balanceOf[liquidityWallet] += (amount * taxLiquidity / FEE_DENOMINATOR);
            emit Transfer(from, liquidityWallet, amount * taxLiquidity / FEE_DENOMINATOR);

            _reflectToHolders((amount * taxReflection / FEE_DENOMINATOR), from);
        }

        balanceOf[from] -= amount;
        balanceOf[to] += taxedAmount;
        emit Transfer(from, to, taxedAmount);

        // Add to holders if new
        if (balanceOf[to] > 0) {
            bool exists = false;
            for (uint256 i = 0; i < holders.length; i++) {
                if (holders[i] == to) {
                    exists = true;
                    break;
                }
            }
            if (!exists) holders.push(to);
        }
    }

    function _reflectToHolders(uint256 amount, address from) internal {
        if (holders.length == 0 || amount == 0) return;
        uint256 share = amount / holders.length;
        for (uint256 i = 0; i < holders.length; i++) {
            balanceOf[holders[i]] += share;
            emit Transfer(from, holders[i], share);
        }
    }

    function burnCounter() external view returns (uint256) {
        return totalBurned;
    }

    function withdrawETH() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    function withdrawToken(address token) external onlyOwner {
        IERC20(token).transfer(owner, IERC20(token).balanceOf(address(this)));
    }

    function mint(address, uint256) external pure {
        revert("Minting disabled");
    }
}

### Requirements:
- Use **ethers.js v5** and **Chai** for testing.
- Import ethers from "ethers".
- Each `describe` and `it` block must be clear, modular, and focused on a single behavior.
- Include tests for:
  - **Deployment**: verify correct initialization and constructor state.
  - **Happy paths**: normal usage for every public or external function.
  - **Reverts**: test invalid inputs, unauthorized access, and failure conditions.
  - **Events**: verify that events are emitted with correct parameters using `.to.emit()`.
  - **Edge cases**: zero values, address(0), max integers, empty strings, etc.
- Include at least one `beforeEach` block to deploy the contract cleanly for each test.
- Do **not** explain or comment in natural language â€” output only TypeScript test code.
- Tests must be runnable in **Hardhat** directly and use ethers v5 API (`ethers.utils`, `ethers.constants`, etc).

### Output:
Output only valid, executable TypeScript test code (`.spec.ts` format), without any Markdown formatting or explanations.