### Objective:
Generate a test suite for the provided Solidity contract based on the provided scaffold. The scaffold already contains sections with `// TODO_AI` comments indicating where you need to complete the test. Your task is to complete these sections with valid test code.

### Input:
1. Solidity Contract:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MockERC20 {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    
    uint256 private _totalSupply;
    string public name = "MockToken";
    string public symbol = "MTK";
    uint8 public decimals = 18;
    
    constructor(uint256 _initialSupply) {
        _totalSupply = _initialSupply;
        _balances[msg.sender] = _initialSupply;
    }
    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
    
    function transfer(address to, uint256 amount) public returns (bool) {
        require(_balances[msg.sender] >= amount, "Insufficient balance");
        _balances[msg.sender] -= amount;
        _balances[to] += amount;
        return true;
    }
    
    function allowance(address _owner, address spender) public view returns (uint256) {
        return _allowances[_owner][spender];
    }
    
    function approve(address spender, uint256 amount) public returns (bool) {
        _allowances[msg.sender][spender] = amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        require(_allowances[from][msg.sender] >= amount, "Insufficient allowance");
        require(_balances[from] >= amount, "Insufficient balance");
        
        _allowances[from][msg.sender] -= amount;
        _balances[from] -= amount;
        _balances[to] += amount;
        return true;
    }
    
    function mint(address to, uint256 amount) public {
        _balances[to] += amount;
        _totalSupply += amount;
    }
}


2. Test Scaffold:
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

  /**
   * Scaffold automatically generated for MockERC20.
   * Blocks marked // TODO_AI must be completed by the LLM.
   */

  describe("MockERC20 — LLM Scaffold", function () {
    async function deployFixture() {
      const [owner, addr1, addr2] = await ethers.getSigners();
      const Factory = await ethers.getContractFactory("MockERC20");
      // TODO_AI: complete constructor parameters if present
      const contract = await Factory.deploy();
      await contract.waitForDeployment();
      return { contract, owner, addr1, addr2 };
    }

    it("basic deployment", async function () {
      const { contract } = await loadFixture(deployFixture);
      expect(await contract.getAddress()).to.properAddress;
    });

    // Events in ABI: —

    
  describe("allowance(address,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.allowance(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.allowance(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.allowance("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("approve(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.approve(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.approve("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("balanceOf(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.balanceOf(addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.balanceOf(addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.balanceOf("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("decimals()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.decimals();
      // TODO_AI: expect(await contract.decimals()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.decimals()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("mint(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.mint(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.mint("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("name()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.name();
      // TODO_AI: expect(await contract.name()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.name()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("symbol()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.symbol();
      // TODO_AI: expect(await contract.symbol()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.symbol()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("totalSupply()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.totalSupply();
      // TODO_AI: expect(await contract.totalSupply()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.totalSupply()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("transfer(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.transfer(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.transfer("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("transferFrom(address,address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.transferFrom(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.transferFrom("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });

  });


### Instructions:
- **Complete coverage**: You must generate test cases for every function in the contract, including:
  - **State-modifying functions** (functions that change the state of the contract).
  - **Getter and setter functions** (ensure getter functions return the correct values).
  - **Pure and view functions** (functions that don't modify the state).
  - **Functions with access control** (e.g., `onlyOwner`, `hasRole`) and verify that only authorized users can call them.
  - **Constructor functions** (ensure the contract is deployed correctly with expected initial states).
  - **Event testing**: For every function that emits events, you must verify that the correct event is emitted with the correct arguments using `.to.emit()`.
  - **Error handling**: Test all error-reverting cases with `.revertedWith()` and ensure the appropriate error messages are shown.
  - **Edge cases**: Test scenarios such as:
    - Invalid inputs (e.g., `address(0)`, empty strings, etc.).
    - Boundary cases (e.g., maximum and minimum values for numeric types).
    - Ensure that all conditions that may revert the function are tested.
  - **Gas optimization**: If applicable, test for gas efficiency in relevant functions.

- Ensure that your tests include:
  - Happy path (normal expected behavior).
  - Error cases (invalid inputs, unauthorized access, etc.).
  - Boundary cases (edge cases, limits, and expected values).
  - Event emissions (verify that correct events are emitted).

- **Format**: Only generate the TypeScript test code. The output should include full test cases for every function in the contract and be executable with **Hardhat** or **Mocha**.
- Use **ethers.js** for interacting with the contract and **Chai** for assertions.

### Output:
Your output should only be the test code in **TypeScript (.ts)** format, including completed tests for all functions and cases as described.

### Example Test:

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";

describe("ContractName", function () {
  it("should return the correct owner", async function () {
    const [owner, addr1] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();
    
    expect(await contract.owner()).to.equal(owner.address);
  });

  it("should revert on invalid address", async function () {
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();

    await expect(
      contract.airdrop("0x0000000000000000000000000000000000000000", 1)
    ).to.be.revertedWith("Invalid address");
  });
});
