### Objective:
Generate a test suite for the provided Solidity contract based on the provided scaffold. The scaffold already contains sections with `// TODO_AI` comments indicating where you need to complete the test. Your task is to complete these sections with valid test code.

### Input:
1. Solidity Contract:
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

/**
 * @title SystemAccessControl
 * @dev A simplified access control contract to manage roles and permissions.
 * This contract is inspired by OpenZeppelin's AccessControl but is self-contained
 * and implemented according to the provided specifications.
 */
contract SystemAccessControl {

    // Role constants
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    bytes32 public constant ADMIN_ROLE = keccak256(abi.encodePacked("ADMIN_ROLE"));
    bytes32 public constant VAULT_ROLE = keccak256(abi.encodePacked("VAULT_ROLE"));
    bytes32 public constant PRICE_PROVIDER_ROLE = keccak256(abi.encodePacked("PRICE_PROVIDER_ROLE"));
    bytes32 public constant LIQUIDATOR_ROLE = keccak256(abi.encodePacked("LIQUIDATOR_ROLE"));
    bytes32 public constant PAUSER_ROLE = keccak256(abi.encodePacked("PAUSER_ROLE"));

    // State variables
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    // Events
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    // Note: RoleAdminChanged event is part of OpenZeppelin's full AccessControl.
    // For this implementation, admin roles are fixed in the constructor.
    // event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);


    // Modifier
    modifier onlyRoleAdmin(bytes32 role) {
        _checkRoleAdmin(role, msg.sender);
        _;
    }

    /**
     * @dev Constructor sets up the initial roles.
     * The deployer (`msg.sender`) gets the DEFAULT_ADMIN_ROLE.
     * DEFAULT_ADMIN_ROLE is set as the admin for all other roles.
     */
    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // Grant DEFAULT_ADMIN_ROLE to deployer

        // Set DEFAULT_ADMIN_ROLE as the admin for all other roles
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(VAULT_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(PRICE_PROVIDER_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(LIQUIDATOR_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(PAUSER_ROLE, DEFAULT_ADMIN_ROLE);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool) {
        return _roles[role].members[account];
    }

    /**
     * @dev Returns the admin role that controls `role`.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * Requirements:
     * - Caller must have the admin role for the `role` being granted.
     *
     * Emits a {RoleGranted} event.
     */
    function grantRole(bytes32 role, address account) external onlyRoleAdmin(role) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * Requirements:
     * - Caller must have the admin role for the `role` being revoked.
     *
     * Emits a {RoleRevoked} event.
     */
    function revokeRole(bytes32 role, address account) external onlyRoleAdmin(role) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     * Roles can be renounced by calling `renounceRole(role, msg.sender)`.
     *
     * Requirements:
     * - `msg.sender` must be `account`.
     *
     * Emits a {RoleRevoked} event.
     */
    function renounceRole(bytes32 role, address account) external {
        if (msg.sender != account) {
            revert("SystemAccessControl: can only renounce roles for self");
        }
        _revokeRole(role, account);
    }

    // Internal helper functions

    /**
     * @dev Internal function to set the admin role for a given role.
     * Used in the constructor.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        // No RoleAdminChanged event emission as per prompt simplification for constructor setup
        _roles[role].adminRole = adminRole;
    }

    /**
     * @dev Internal function to grant a role and set its admin.
     * For DEFAULT_ADMIN_ROLE, adminOrMember is the first member and also its own admin.
     * For other roles, this is primarily used to grant the role to an initial member if needed,
     * but admin roles are set separately by _setRoleAdmin in the constructor.
     */
    function _setupRole(bytes32 role, address adminOrMember) internal {
        if (role == DEFAULT_ADMIN_ROLE) {
            _setRoleAdmin(role, role); // DEFAULT_ADMIN_ROLE is its own admin
        }
        _grantRole(role, adminOrMember);
    }

    /**
     * @dev Internal logic for granting a role.
     */
    function _grantRole(bytes32 role, address account) internal {
        if (!_roles[role].members[account]) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    /**
     * @dev Internal logic for revoking a role.
     */
    function _revokeRole(bytes32 role, address account) internal {
        if (_roles[role].members[account]) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }

    /**
     * @dev Internal function to check if `sender` has the admin role for `role`.
     * Used by the `onlyRoleAdmin` modifier.
     */
    function _checkRoleAdmin(bytes32 role, address sender) internal view {
        bytes32 adminRoleForGivenRole = _roles[role].adminRole;
        if (!_roles[adminRoleForGivenRole].members[sender]) {
            revert("SystemAccessControl: sender must be admin to grant/revoke role");
        }
    }
}

2. Test Scaffold:
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

  /**
   * Scaffold automatically generated for SystemAccessControl.
   * Blocks marked // TODO_AI must be completed by the LLM.
   */

  describe("SystemAccessControl â€” LLM Scaffold", function () {
    async function deployFixture() {
      const [owner, addr1, addr2] = await ethers.getSigners();
      const Factory = await ethers.getContractFactory("SystemAccessControl");
      // TODO_AI: complete constructor parameters if present
      const contract = await Factory.deploy();
      await contract.waitForDeployment();
      return { contract, owner, addr1, addr2 };
    }

    it("basic deployment", async function () {
      const { contract } = await loadFixture(deployFixture);
      expect(await contract.getAddress()).to.properAddress;
    });

    // Events in ABI: RoleGranted, RoleRevoked

    
  describe("ADMIN_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.ADMIN_ROLE();
      // TODO_AI: expect(await contract.ADMIN_ROLE()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.ADMIN_ROLE()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("DEFAULT_ADMIN_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.DEFAULT_ADMIN_ROLE();
      // TODO_AI: expect(await contract.DEFAULT_ADMIN_ROLE()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.DEFAULT_ADMIN_ROLE()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("LIQUIDATOR_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.LIQUIDATOR_ROLE();
      // TODO_AI: expect(await contract.LIQUIDATOR_ROLE()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.LIQUIDATOR_ROLE()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("PAUSER_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.PAUSER_ROLE();
      // TODO_AI: expect(await contract.PAUSER_ROLE()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.PAUSER_ROLE()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("PRICE_PROVIDER_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.PRICE_PROVIDER_ROLE();
      // TODO_AI: expect(await contract.PRICE_PROVIDER_ROLE()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.PRICE_PROVIDER_ROLE()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("VAULT_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.VAULT_ROLE();
      // TODO_AI: expect(await contract.VAULT_ROLE()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.VAULT_ROLE()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("getRoleAdmin(bytes32)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.getRoleAdmin("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */);
      // TODO_AI: expect(await contract.getRoleAdmin("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.getRoleAdmin("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("grantRole(bytes32,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.grantRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.grantRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("hasRole(bytes32,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.hasRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.hasRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.hasRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("renounceRole(bytes32,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.renounceRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.renounceRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("revokeRole(bytes32,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.revokeRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.revokeRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });

  });


### Instructions:
- **Complete coverage**: You must generate test cases for every function in the contract, including:
  - **State-modifying functions** (functions that change the state of the contract).
  - **Getter and setter functions** (ensure getter functions return the correct values).
  - **Pure and view functions** (functions that don't modify the state).
  - **Functions with access control** (e.g., `onlyOwner`, `hasRole`) and verify that only authorized users can call them.
  - **Constructor functions** (ensure the contract is deployed correctly with expected initial states).
  - **Event testing**: For every function that emits events, you must verify that the correct event is emitted with the correct arguments using `.to.emit()`.
  - **Error handling**: Test all error-reverting cases with `.revertedWith()` and ensure the appropriate error messages are shown.
  - **Edge cases**: Test scenarios such as:
    - Invalid inputs (e.g., `address(0)`, empty strings, etc.).
    - Boundary cases (e.g., maximum and minimum values for numeric types).
    - Ensure that all conditions that may revert the function are tested.
  - **Gas optimization**: If applicable, test for gas efficiency in relevant functions.

- Ensure that your tests include:
  - Happy path (normal expected behavior).
  - Error cases (invalid inputs, unauthorized access, etc.).
  - Boundary cases (edge cases, limits, and expected values).
  - Event emissions (verify that correct events are emitted).

- **Format**: Only generate the TypeScript test code. The output should include full test cases for every function in the contract and be executable with **Hardhat** or **Mocha**.
- Use **ethers.js** for interacting with the contract and **Chai** for assertions.

### Output:
Your output should only be the test code in **TypeScript (.ts)** format, including completed tests for all functions and cases as described.

### Example Test:

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";

describe("ContractName", function () {
  it("should return the correct owner", async function () {
    const [owner, addr1] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();
    
    expect(await contract.owner()).to.equal(owner.address);
  });

  it("should revert on invalid address", async function () {
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();

    await expect(
      contract.airdrop("0x0000000000000000000000000000000000000000", 1)
    ).to.be.revertedWith("Invalid address");
  });
});
