### Objective:
Generate a test suite for the provided Solidity contract based on the provided scaffold. The scaffold already contains sections with `// TODO_AI` comments indicating where you need to complete the test. Your task is to complete these sections with valid test code.

### Input:
1. Solidity Contract:
// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

address constant ZAMM = 0x00000000000008882D72EfA6cCE4B6a40b24C860;

struct PoolKey {
    uint256 id0;
    uint256 id1;
    address token0;
    address token1;
    uint96 swapFee;
}

interface IZAMM {
    function addLiquidity(
        PoolKey calldata poolKey,
        uint256 amount0Desired,
        uint256 amount1Desired,
        uint256 amount0Min,
        uint256 amount1Min,
        address to,
        uint256 deadline
    ) external payable returns (uint256 amount0, uint256 amount1, uint256 liquidity);
    
    function swapExactIn(
        PoolKey calldata poolKey,
        uint256 amountIn,
        uint256 amountOutMin,
        bool zeroForOne,
        address to,
        uint256 deadline
    ) external payable returns (uint256 amountOut);
    
    function recoverTransientBalance(address token, uint256 id, address to) external returns (uint256 amount);
}

contract ZAMMSingleLiqETH {
    error InvalidPoolKey();

    function addSingleLiqETH(
        PoolKey calldata poolKey,
        uint256 amountOutMin,  
        uint256 amount0Min,    
        uint256 amount1Min,    
        address to,
        uint256 deadline
    ) public payable returns (uint256 amount0, uint256 amount1, uint256 liquidity) {
        unchecked {
            require(poolKey.token0 == address(0), InvalidPoolKey());
            
            assembly ("memory-safe") {
                pop(call(gas(), ZAMM, callvalue(), codesize(), 0x00, codesize(), 0x00))
            }
            
            uint256 halfETH = msg.value / 2;
            
            uint256 token1Amount = IZAMM(ZAMM).swapExactIn(
                poolKey,
                halfETH,
                amountOutMin,
                true, 
                ZAMM,
                deadline
            );
            
            (amount0, amount1, liquidity) = IZAMM(ZAMM).addLiquidity(
                poolKey,
                halfETH,  
                token1Amount,         
                amount0Min,           
                amount1Min,           
                to,                   
                deadline
            );
            
            IZAMM(ZAMM).recoverTransientBalance(address(0), 0, msg.sender);
            IZAMM(ZAMM).recoverTransientBalance(poolKey.token1, poolKey.id1, msg.sender);
        }
    }
}

2. Test Scaffold:
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

  /**
   * Scaffold automatically generated for ZAMMSingleLiqETH.
   * Blocks marked // TODO_AI must be completed by the LLM.
   */

  describe("ZAMMSingleLiqETH — LLM Scaffold", function () {
    async function deployFixture() {
      const [owner, addr1, addr2] = await ethers.getSigners();
      const Factory = await ethers.getContractFactory("ZAMMSingleLiqETH");
      // TODO_AI: complete constructor parameters if present
      const contract = await Factory.deploy();
      await contract.waitForDeployment();
      return { contract, owner, addr1, addr2 };
    }

    it("basic deployment", async function () {
      const { contract } = await loadFixture(deployFixture);
      expect(await contract.getAddress()).to.properAddress;
    });

    // Events in ABI: —

    
  describe("addSingleLiqETH(tuple,uint256,uint256,uint256,address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.addSingleLiqETH({ /* TODO_AI tuple */ }, 1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */, addr1.address /* TODO_AI */, 1n /* TODO_AI */, { value: 1n /* TODO_AI in wei */ });
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.addSingleLiqETH({ /* TODO_AI invalid tuple */ }, 0n /* TODO_AI: make invalid/edge */, 0n /* TODO_AI: make invalid/edge */, 0n /* TODO_AI: make invalid/edge */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */, 0n /* TODO_AI: make invalid/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });

  });


### Instructions:
- **Complete coverage**: You must generate test cases for every function in the contract, including:
  - **State-modifying functions** (functions that change the state of the contract).
  - **Getter and setter functions** (ensure getter functions return the correct values).
  - **Pure and view functions** (functions that don't modify the state).
  - **Functions with access control** (e.g., `onlyOwner`, `hasRole`) and verify that only authorized users can call them.
  - **Constructor functions** (ensure the contract is deployed correctly with expected initial states).
  - **Event testing**: For every function that emits events, you must verify that the correct event is emitted with the correct arguments using `.to.emit()`.
  - **Error handling**: Test all error-reverting cases with `.revertedWith()` and ensure the appropriate error messages are shown.
  - **Edge cases**: Test scenarios such as:
    - Invalid inputs (e.g., `address(0)`, empty strings, etc.).
    - Boundary cases (e.g., maximum and minimum values for numeric types).
    - Ensure that all conditions that may revert the function are tested.
  - **Gas optimization**: If applicable, test for gas efficiency in relevant functions.

- Ensure that your tests include:
  - Happy path (normal expected behavior).
  - Error cases (invalid inputs, unauthorized access, etc.).
  - Boundary cases (edge cases, limits, and expected values).
  - Event emissions (verify that correct events are emitted).

- **Format**: Only generate the TypeScript test code. The output should include full test cases for every function in the contract and be executable with **Hardhat** or **Mocha**.
- Use **ethers.js** for interacting with the contract and **Chai** for assertions.

### Output:
Your output should only be the test code in **TypeScript (.ts)** format, including completed tests for all functions and cases as described.

### Example Test:

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";

describe("ContractName", function () {
  it("should return the correct owner", async function () {
    const [owner, addr1] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();
    
    expect(await contract.owner()).to.equal(owner.address);
  });

  it("should revert on invalid address", async function () {
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();

    await expect(
      contract.airdrop("0x0000000000000000000000000000000000000000", 1)
    ).to.be.revertedWith("Invalid address");
  });
});
