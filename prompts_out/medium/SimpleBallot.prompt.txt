### Objective:
Generate a test suite for the provided Solidity contract based on the provided scaffold. The scaffold already contains sections with `// TODO_AI` comments indicating where you need to complete the test. Your task is to complete these sections with valid test code.

### Input:
1. Solidity Contract:
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.20 <0.9.0;

/// @title SimpleBallot - A simple voting contract with chairperson-controlled voter registration
/// @author 
/// @notice This contract allows a chairperson to register voters and conduct a vote on predefined proposals.
/// @dev Uses custom errors, events, and access control modifier for clarity and security.
contract SimpleBallot {
    /// @notice Proposal structure containing name and vote count
    struct Proposal {
        string name;
        uint256 voteCount;
    }

    /// @notice Voter structure containing registration status, voting status, and voted proposal index
    struct Voter {
        bool registered;
        bool voted;
        uint256 vote;
    }

    /// @notice Address of the chairperson (deployer)
    address public immutable chairperson;

    /// @notice Array of proposals available for voting
    Proposal[] public proposals;

    /// @notice Mapping from voter address to Voter info
    mapping(address => Voter) public voters;

    /// @notice Emitted when a voter is registered by the chairperson
    /// @param voter The address of the registered voter
    event VoterRegistered(address indexed voter);

    /// @notice Emitted when a registered voter casts their vote
    /// @param voter The address of the voter who cast the vote
    /// @param proposalIndex The index of the proposal voted for
    event VoteCast(address indexed voter, uint256 indexed proposalIndex);

    /// @notice Error thrown when caller is not the chairperson
    error NotChairperson();

    /// @notice Error thrown when an action requires a registered voter but caller is not registered
    error NotRegistered();

    /// @notice Error thrown when a voter attempts to vote more than once
    error AlreadyVoted();

    /// @notice Error thrown when a given proposal index is invalid (out of range)
    error InvalidProposal();

    /// @notice Error thrown when no proposals are provided at deployment
    error NoProposals();

    /// @notice Modifier to restrict function access to only the chairperson
    modifier onlyChairperson() {
        if (msg.sender != chairperson) revert NotChairperson();
        _;
    }

    /// @notice Contract constructor sets the chairperson and initializes proposals
    /// @param proposalNames Array of proposal names to initialize voting options
    constructor(string[] memory proposalNames) {
        if (proposalNames.length == 0) revert NoProposals();
        chairperson = msg.sender;
        for (uint256 i = 0; i < proposalNames.length; i++) {
            proposals.push(Proposal({name: proposalNames[i], voteCount: 0}));
        }
    }

    /// @notice Register a voter; only callable by the chairperson.
    ///         Idempotent: does nothing if already registered.
    /// @param voter Address of the voter to register
    function registerVoter(address voter) external onlyChairperson {
        Voter storage v = voters[voter];
        if (!v.registered) {
            v.registered = true;
            emit VoterRegistered(voter);
        }
        // else do nothing (idempotent)
    }

    /// @notice Cast a vote for a given proposal index; caller must be registered and not have voted before.
    /// @param proposalIndex Index of the proposal to vote for
    function vote(uint256 proposalIndex) external {
        Voter storage sender = voters[msg.sender];
        if (!sender.registered) revert NotRegistered();
        if (sender.voted) revert AlreadyVoted();
        if (proposalIndex >= proposals.length) revert InvalidProposal();

        sender.voted = true;
        sender.vote = proposalIndex;
        unchecked {
            proposals[proposalIndex].voteCount++;
        }
        emit VoteCast(msg.sender, proposalIndex);
    }

    /// @notice Returns the winning proposal's index, name, and vote count.
    /// @return index The index of the winning proposal
    /// @return name The name of the winning proposal
    /// @return votes The number of votes the winning proposal received
    function winner() public view returns (uint256 index, string memory name, uint256 votes) {
        uint256 winningVoteCount = 0;
        uint256 winningIndex = 0;

        for (uint256 i = 0; i < proposals.length; i++) {
            if (proposals[i].voteCount > winningVoteCount) {
                winningVoteCount = proposals[i].voteCount;
                winningIndex = i;
            }
        }
        return (winningIndex, proposals[winningIndex].name, winningVoteCount);
    }
}

2. Test Scaffold:
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

  /**
   * Scaffold automatically generated for SimpleBallot.
   * Blocks marked // TODO_AI must be completed by the LLM.
   */

  describe("SimpleBallot â€” LLM Scaffold", function () {
    async function deployFixture() {
      const [owner, addr1, addr2] = await ethers.getSigners();
      const Factory = await ethers.getContractFactory("SimpleBallot");
      // TODO_AI: complete constructor parameters if present
      const contract = await Factory.deploy();
      await contract.waitForDeployment();
      return { contract, owner, addr1, addr2 };
    }

    it("basic deployment", async function () {
      const { contract } = await loadFixture(deployFixture);
      expect(await contract.getAddress()).to.properAddress;
    });

    // Events in ABI: VoteCast, VoterRegistered

    
  describe("chairperson()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.chairperson();
      // TODO_AI: expect(await contract.chairperson()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.chairperson()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("proposals(uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.proposals(1n /* TODO_AI */);
      // TODO_AI: expect(await contract.proposals(1n /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.proposals(0n /* TODO_AI: make invalid/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("registerVoter(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.registerVoter(addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.registerVoter("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("vote(uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.vote(1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.vote(0n /* TODO_AI: make invalid/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("voters(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.voters(addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.voters(addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.voters("0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("winner()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.winner();
      // TODO_AI: expect(await contract.winner()).to.equal(/* atteso */);
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.winner()
      ).to.be.reverted; // TODO_AI: .with("MESSAGE")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });

  });


### Instructions:
- **Complete coverage**: You must generate test cases for every function in the contract, including:
  - **State-modifying functions** (functions that change the state of the contract).
  - **Getter and setter functions** (ensure getter functions return the correct values).
  - **Pure and view functions** (functions that don't modify the state).
  - **Functions with access control** (e.g., `onlyOwner`, `hasRole`) and verify that only authorized users can call them.
  - **Constructor functions** (ensure the contract is deployed correctly with expected initial states).
  - **Event testing**: For every function that emits events, you must verify that the correct event is emitted with the correct arguments using `.to.emit()`.
  - **Error handling**: Test all error-reverting cases with `.revertedWith()` and ensure the appropriate error messages are shown.
  - **Edge cases**: Test scenarios such as:
    - Invalid inputs (e.g., `address(0)`, empty strings, etc.).
    - Boundary cases (e.g., maximum and minimum values for numeric types).
    - Ensure that all conditions that may revert the function are tested.
  - **Gas optimization**: If applicable, test for gas efficiency in relevant functions.

- Ensure that your tests include:
  - Happy path (normal expected behavior).
  - Error cases (invalid inputs, unauthorized access, etc.).
  - Boundary cases (edge cases, limits, and expected values).
  - Event emissions (verify that correct events are emitted).

- **Format**: Only generate the TypeScript test code. The output should include full test cases for every function in the contract and be executable with **Hardhat** or **Mocha**.
- Use **ethers.js** for interacting with the contract and **Chai** for assertions.

### Output:
Your output should only be the test code in **TypeScript (.ts)** format, including completed tests for all functions and cases as described.

### Example Test:

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";

describe("ContractName", function () {
  it("should return the correct owner", async function () {
    const [owner, addr1] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();
    
    expect(await contract.owner()).to.equal(owner.address);
  });

  it("should revert on invalid address", async function () {
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();

    await expect(
      contract.airdrop("0x0000000000000000000000000000000000000000", 1)
    ).to.be.revertedWith("Invalid address");
  });
});
