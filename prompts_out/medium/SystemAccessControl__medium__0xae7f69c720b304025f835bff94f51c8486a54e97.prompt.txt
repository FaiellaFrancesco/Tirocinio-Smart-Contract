You are an expert blockchain developer specialized in writing professional and reliable test suites for Solidity smart contracts using Hardhat, Mocha, and Chai.

### Goal:
Generate a complete TypeScript test suite for the provided Solidity smart contract.

### SCAFFOLD:
import { expect } from "chai";
  import hre from "hardhat";
  import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

  /**
   * Scaffold automatically generated for contracts/medium/0xae7f69c720b304025f835bff94f51c8486a54e97.sol:SystemAccessControl.
   * Blocks marked // TODO_AI must be completed by the LLM.
   */

  describe("contracts/medium/0xae7f69c720b304025f835bff94f51c8486a54e97.sol:SystemAccessControl â€” LLM Scaffold", function () {
    async function deployFixture() {
      const { ethers } = (await import("hardhat")).default;
      const [owner, addr1, addr2] = await ethers.getSigners();
      const Factory = await ethers.getContractFactory("SystemAccessControl");
      // TODO_AI: complete constructor parameters if present
      const contract = await Factory.deploy();
      await contract.waitForDeployment();
      return { contract, owner, addr1, addr2 };
    }

    it("basic deployment", async function () {
      const { contract } = await loadFixture(deployFixture);
      expect(await contract.getAddress()).to.match(/^0x[a-fA-F0-9]{40}$/);
    });

    // Events in ABI: RoleGranted, RoleRevoked

    
  describe("ADMIN_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.ADMIN_ROLE();
      // TODO_AI: expect(await contract.ADMIN_ROLE()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("DEFAULT_ADMIN_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.DEFAULT_ADMIN_ROLE();
      // TODO_AI: expect(await contract.DEFAULT_ADMIN_ROLE()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("LIQUIDATOR_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.LIQUIDATOR_ROLE();
      // TODO_AI: expect(await contract.LIQUIDATOR_ROLE()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("PAUSER_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.PAUSER_ROLE();
      // TODO_AI: expect(await contract.PAUSER_ROLE()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("PRICE_PROVIDER_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.PRICE_PROVIDER_ROLE();
      // TODO_AI: expect(await contract.PRICE_PROVIDER_ROLE()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("VAULT_ROLE()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.VAULT_ROLE();
      // TODO_AI: expect(await contract.VAULT_ROLE()).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("getRoleAdmin(bytes32)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.getRoleAdmin("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */);
      // TODO_AI: expect(await contract.getRoleAdmin("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */)).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("grantRole(bytes32,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.grantRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.grantRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.revertedWith(/* TODO_AI: inserire messaggio */);
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("hasRole(bytes32,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // read-only call
      const result = await contract.hasRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.hasRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("renounceRole(bytes32,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.renounceRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.renounceRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.revertedWith(/* TODO_AI: inserire messaggio */);
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });


  describe("revokeRole(bytes32,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // state-changing transaction
      const result = await contract.revokeRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts on invalid input/role", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.revokeRole("0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" /* TODO_AI */, "0x0000000000000000000000000000000000000000" /* TODO_AI: use zero/unauthorized */)
      ).to.be.revertedWith(/* TODO_AI: inserire messaggio */);
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), role limits, etc.
    });

    // TODO_AI: if emits events: await expect(tx).to.emit(contract, "Event").withArgs(...)
  });

  });


### Contract:
// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

/**
 * @title SystemAccessControl
 * @dev A simplified access control contract to manage roles and permissions.
 * This contract is inspired by OpenZeppelin's AccessControl but is self-contained
 * and implemented according to the provided specifications.
 */
contract SystemAccessControl {

    // Role constants
    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    bytes32 public constant ADMIN_ROLE = keccak256(abi.encodePacked("ADMIN_ROLE"));
    bytes32 public constant VAULT_ROLE = keccak256(abi.encodePacked("VAULT_ROLE"));
    bytes32 public constant PRICE_PROVIDER_ROLE = keccak256(abi.encodePacked("PRICE_PROVIDER_ROLE"));
    bytes32 public constant LIQUIDATOR_ROLE = keccak256(abi.encodePacked("LIQUIDATOR_ROLE"));
    bytes32 public constant PAUSER_ROLE = keccak256(abi.encodePacked("PAUSER_ROLE"));

    // State variables
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    // Events
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    // Note: RoleAdminChanged event is part of OpenZeppelin's full AccessControl.
    // For this implementation, admin roles are fixed in the constructor.
    // event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);


    // Modifier
    modifier onlyRoleAdmin(bytes32 role) {
        _checkRoleAdmin(role, msg.sender);
        _;
    }

    /**
     * @dev Constructor sets up the initial roles.
     * The deployer (`msg.sender`) gets the DEFAULT_ADMIN_ROLE.
     * DEFAULT_ADMIN_ROLE is set as the admin for all other roles.
     */
    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender); // Grant DEFAULT_ADMIN_ROLE to deployer

        // Set DEFAULT_ADMIN_ROLE as the admin for all other roles
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(VAULT_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(PRICE_PROVIDER_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(LIQUIDATOR_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(PAUSER_ROLE, DEFAULT_ADMIN_ROLE);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool) {
        return _roles[role].members[account];
    }

    /**
     * @dev Returns the admin role that controls `role`.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * Requirements:
     * - Caller must have the admin role for the `role` being granted.
     *
     * Emits a {RoleGranted} event.
     */
    function grantRole(bytes32 role, address account) external onlyRoleAdmin(role) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * Requirements:
     * - Caller must have the admin role for the `role` being revoked.
     *
     * Emits a {RoleRevoked} event.
     */
    function revokeRole(bytes32 role, address account) external onlyRoleAdmin(role) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     * Roles can be renounced by calling `renounceRole(role, msg.sender)`.
     *
     * Requirements:
     * - `msg.sender` must be `account`.
     *
     * Emits a {RoleRevoked} event.
     */
    function renounceRole(bytes32 role, address account) external {
        if (msg.sender != account) {
            revert("SystemAccessControl: can only renounce roles for self");
        }
        _revokeRole(role, account);
    }

    // Internal helper functions

    /**
     * @dev Internal function to set the admin role for a given role.
     * Used in the constructor.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
        // No RoleAdminChanged event emission as per prompt simplification for constructor setup
        _roles[role].adminRole = adminRole;
    }

    /**
     * @dev Internal function to grant a role and set its admin.
     * For DEFAULT_ADMIN_ROLE, adminOrMember is the first member and also its own admin.
     * For other roles, this is primarily used to grant the role to an initial member if needed,
     * but admin roles are set separately by _setRoleAdmin in the constructor.
     */
    function _setupRole(bytes32 role, address adminOrMember) internal {
        if (role == DEFAULT_ADMIN_ROLE) {
            _setRoleAdmin(role, role); // DEFAULT_ADMIN_ROLE is its own admin
        }
        _grantRole(role, adminOrMember);
    }

    /**
     * @dev Internal logic for granting a role.
     */
    function _grantRole(bytes32 role, address account) internal {
        if (!_roles[role].members[account]) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    /**
     * @dev Internal logic for revoking a role.
     */
    function _revokeRole(bytes32 role, address account) internal {
        if (_roles[role].members[account]) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }

    /**
     * @dev Internal function to check if `sender` has the admin role for `role`.
     * Used by the `onlyRoleAdmin` modifier.
     */
    function _checkRoleAdmin(bytes32 role, address sender) internal view {
        bytes32 adminRoleForGivenRole = _roles[role].adminRole;
        if (!_roles[adminRoleForGivenRole].members[sender]) {
            revert("SystemAccessControl: sender must be admin to grant/revoke role");
        }
    }
}


-### Instructions:
- Use **ethers.js v5** and **Chai** for testing.
- Import ethers from "ethers".

  - **Deployment**: Verify correct initialization and constructor state.
  - **Happy paths**: Normal usage for every public or external function.
  - **Reverts**: Test invalid inputs, unauthorized access, and failure conditions.
  - **Events**: Verify that events are emitted with correct parameters using `.to.emit()`.
  - **Edge cases**: Test cases like zero values, address(0), max integers, empty strings, etc.


### Output:
Your output should include **only valid, executable TypeScript test code** (`.spec.ts` format). The code should be complete and ready to execute with Hardhat.

### Test Requirements:
- Use **ethers.js v5** (specifically `ethers.utils` and `ethers.constants`).
- Ensure all test functions are structured clearly:
  - **State-modifying functions**: Test changes to contract state.
  - **Getter and setter functions**: Ensure getters return the correct value and setters correctly modify state.
  - **Pure and view functions**: Ensure that state is not modified and the correct values are returned.
  - **Access control functions**: Verify that only authorized accounts (e.g., owner, specific roles) can call functions with appropriate access control.
  - **Event emission**: Verify the correct emission of events with proper arguments, using `.to.emit()`.
  - **Error handling**: Ensure functions revert with appropriate error messages on invalid inputs.
  - **Edge cases**: Handle boundary conditions, such as `address(0)`, maximum integers, and empty strings.

---

### Example Test:

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";

describe("ContractName", function () {
  it("should return the correct owner", async function () {
    const [owner, addr1] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();
    
    expect(await contract.owner()).to.equal(owner.address);
  });

  it("should revert on invalid address", async function () {
    const Contract = await ethers.getContractFactory("ContractName");
    const contract = await Contract.deploy();
    await contract.deployed();

    await expect(
      contract.airdrop("0x0000000000000000000000000000000000000000", 1)
    ).to.be.revertedWith("Invalid address");
  });
});