Sei un generatore di test Hardhat (TypeScript) per Mocha/Chai.
Ti fornisco uno SCHEMA con blocchi // TODO_AI.
COMPLETA SOLO i TODO_AI (asserzioni, input, messaggi di revert, event args).
NON cambiare imports/describe/it, né aggiungere librerie esterne.
Per funzioni view/pure NON aspettarti revert: asserisci il valore atteso.
Per funzioni che modificano stato:
  - almeno 1 happy path con verifica di stato/eventi,
  - almeno 1 caso di revert (.to.be.reverted(.with(...))),
  - boundary (0, max, address(0), ruoli).
Se serve ETH, usa { value: <bigint in wei> }.
Usa i signer: owner, addr1, addr2.

OUTPUT: restituisci l’intero file COMPLETO in un UNICO blocco ```ts ... ``` senza testo extra.

<FILE>
```ts
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

/**
 * Scaffold generato automaticamente per SWAN.
 * I blocchi // TODO_AI vanno completati dall'LLM.
 */

describe("SWAN — LLM Scaffold", function () {
  async function deployFixture() {
    const [owner, addr1, addr2] = await ethers.getSigners();
    const Factory = await ethers.getContractFactory("SWAN");
    // TODO_AI: completa i parametri del costruttore se presenti
    const contract = await Factory.deploy();
    await contract.waitForDeployment();
    return { contract, owner, addr1, addr2 };
  }

  it("deployment di base", async function () {
    const { contract } = await loadFixture(deployFixture);
    expect(await contract.getAddress()).to.properAddress;
  });

  // Eventi in ABI: Approval, AutoLiquify, ClearStuck, ClearToken, EditTax, OwnershipTransferred, Transfer, set_MaxTX, set_MaxWallet, set_Receivers, set_SwapBack, user_TxExempt, user_exemptfromfees

  
  describe("TradingOpen()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.TradingOpen();
      // TODO_AI: expect(await contract.TradingOpen()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.TradingOpen()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("_maxTxAmount()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract._maxTxAmount();
      // TODO_AI: expect(await contract._maxTxAmount()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract._maxTxAmount()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("_maxWalletToken()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract._maxWalletToken();
      // TODO_AI: expect(await contract._maxWalletToken()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract._maxWalletToken()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("_owner()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract._owner();
      // TODO_AI: expect(await contract._owner()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract._owner()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("allowance(address,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.allowance(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.allowance(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.allowance("0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, "0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("approve(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.approve(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.approve("0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, 0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("approveMax(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.approveMax(addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.approveMax("0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("balanceOf(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.balanceOf(addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.balanceOf(addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.balanceOf("0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("checkRatio(uint256,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.checkRatio(1n /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: expect(await contract.checkRatio(1n /* TODO_AI */, 1n /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.checkRatio(0n /* TODO_AI: rendi invalido/edge */, 0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("clearStuckToken(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.clearStuckToken(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.clearStuckToken("0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, 0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("decimals()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.decimals();
      // TODO_AI: expect(await contract.decimals()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.decimals()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("getOwner()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.getOwner();
      // TODO_AI: expect(await contract.getOwner()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.getOwner()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("manualSend()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.manualSend();
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.manualSend()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("maxWalletRule(uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.maxWalletRule(1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.maxWalletRule(0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("name()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.name();
      // TODO_AI: expect(await contract.name()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.name()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("owner()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.owner();
      // TODO_AI: expect(await contract.owner()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.owner()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("pair()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.pair();
      // TODO_AI: expect(await contract.pair()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.pair()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("reduceFee()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.reduceFee();
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.reduceFee()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("removeLimits()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.removeLimits();
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.removeLimits()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("renounceOwnership()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.renounceOwnership();
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.renounceOwnership()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("router()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.router();
      // TODO_AI: expect(await contract.router()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.router()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("setParameters(uint256,uint256,uint256,uint256,uint256,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.setParameters(1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.setParameters(0n /* TODO_AI: rendi invalido/edge */, 0n /* TODO_AI: rendi invalido/edge */, 0n /* TODO_AI: rendi invalido/edge */, 0n /* TODO_AI: rendi invalido/edge */, 0n /* TODO_AI: rendi invalido/edge */, 0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("setStructure(uint256,uint256,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.setStructure(1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.setStructure(0n /* TODO_AI: rendi invalido/edge */, 0n /* TODO_AI: rendi invalido/edge */, 0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("setSwapBackSettings(bool,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.setSwapBackSettings(true /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.setSwapBackSettings(false /* TODO_AI */, 0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("setWallets(address,address,address,address,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.setWallets(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */, addr1.address /* TODO_AI */, addr1.address /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.setWallets("0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, "0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, "0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, "0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, "0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("showBacking(uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.showBacking(1n /* TODO_AI */);
      // TODO_AI: expect(await contract.showBacking(1n /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.showBacking(0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("showSupply()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.showSupply();
      // TODO_AI: expect(await contract.showSupply()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.showSupply()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("startTrading()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.startTrading();
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.startTrading()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("swapEnabled()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.swapEnabled();
      // TODO_AI: expect(await contract.swapEnabled()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.swapEnabled()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("swapThreshold()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.swapThreshold();
      // TODO_AI: expect(await contract.swapThreshold()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.swapThreshold()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("symbol()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.symbol();
      // TODO_AI: expect(await contract.symbol()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.symbol()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("totalFee()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.totalFee();
      // TODO_AI: expect(await contract.totalFee()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.totalFee()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("totalSupply()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.totalSupply();
      // TODO_AI: expect(await contract.totalSupply()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.totalSupply()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("transfer(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.transfer(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.transfer("0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, 0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("transferFrom(address,address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.transferFrom(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.transferFrom("0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, "0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */, 0n /* TODO_AI: rendi invalido/edge */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("transferOwnership(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.transferOwnership(addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.transferOwnership("0x0000000000000000000000000000000000000000" /* TODO_AI: usa zero/non autorizzato */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });

});
