YOU ARE STRICTLY A Hardhat local unit-test generator (Mocha/Chai + Ethers v6).

PREVIOUS ATTEMPT ERRORS:
CRITICAL ERRORS (must fix):
- Found skipped tests (this.skip / .skip). Must be removed.

Please fix ALL errors above. Pay special attention to:
- Missing variable declarations (owner, addr1, addr2 should be from loadFixture)
- Correct imports and TypeScript syntax
- Proper Chai assertion syntax (.to.be.revertedWith, .to.emit, etc.)



MUST:
- Use Hardhat local network with `ethers.getSigners()` and `loadFixture(deployFixture)`.
- Keep `import { ethers } from "hardhat";` exactly as in the scaffold.
- Fix ALL errors from previous attempts shown above.
NEVER:
- Create providers or wallets (`new ethers.JsonRpcProvider`, `new ethers.Wallet`, RPC URLs, Infura/Alchemy).
- Import from "ethers" package in tests.
- Use `new ethers.Contract(...)` with ABI/address; always deploy via `getContractFactory(...).deploy(...)`.
- Use BigInt literals (100n) - use ethers.parseEther("100") instead.
- Use undefined variables like addr1, addr2 - get them from loadFixture.
- Use .revertedWithCustomError or .properAddress - use correct Chai syntax.
If you violate any NEVER rule, your output is invalid and will be discarded.

GOLDEN EXAMPLE (pattern to imitate; do NOT import from "ethers"):
```ts
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
describe("X", function () {
  async function deployFixture() {
    const [owner, a1] = await ethers.getSigners();
    const F = await ethers.getContractFactory("X");
    const c = await F.deploy(); await c.waitForDeployment();
    return { c, owner, a1 };
  }
  it("state change + event", async () => {
    const { c, owner, a1 } = await loadFixture(deployFixture);
    const tx = await c.transfer(a1.address, 1n);
    await expect(tx).to.emit(c, "Transfer").withArgs(owner.address, a1.address, 1n);
    expect(await c.balanceOf(a1.address)).to.equal(1n);
  });
});
```

Target contract: MockERC20

Goal: complete the given SCAFFOLD by replacing EVERY `TODO_AI` with WORKING code. Output must be a single compilable `.spec.ts` using Hardhat + Ethers v6.

ABI SUMMARY (do NOT invent anything outside this list):
FUNCTIONS:
allowance(address,address)->view
approve(address,uint256)->nonpayable
balanceOf(address)->view
decimals()->view
mint(address,uint256)->nonpayable
name()->view
symbol()->view
totalSupply()->view
transfer(address,uint256)->nonpayable
transferFrom(address,address,uint256)->nonpayable
EVENTS:
LLM NOTES (follow strictly):
- Remove this.skip() and fill TODO_AI blocks when implementing tests.
- Use Ethers v6 (no ethers.utils), bigint literals, ethers.ZeroAddress.
- View/Pure: assert return values. State-changing: happy path + revert + boundary.
- Do NOT introduce functions that are not listed above.

EVENTS:
LLM NOTES (follow strictly):
- Remove this.skip() and fill TODO_AI blocks when implementing tests.
- Use Ethers v6 (no ethers.utils), bigint literals, ethers.ZeroAddress.
- View/Pure: assert return values. State-changing: happy path + revert + boundary.
- Do NOT introduce functions that are not listed above.

HARD CONSTRAINTS
1) Output format
   - Respond with ONE code block only, fenced as ```ts ... ``` containing the FULL final file (from imports to last brace).
   - No explanations, no extra text, no multiple fences.

2) Ethers v6 only
   - Use `ethers.parseUnits`, `ethers.parseEther`, `ethers.ZeroAddress`, `ethers.MaxUint256`.
   - Do NOT use `ethers.utils.*` or `ethers.constants.*`.
   - Never create external providers or wallets. Tests MUST run on the Hardhat local network using `ethers.getSigners()` and `loadFixture(deployFixture)`.
   - Do NOT import from 'ethers'. Keep the scaffold import: `import { ethers } from "hardhat";`.

3) Keep the scaffold structure
   - Preserve imports, `describe/it` titles, and the `loadFixture(deployFixture)` pattern.
   - Do NOT add global hooks or new dependencies.

4) ABI-only guard (strict)
   - You MUST call ONLY functions listed in FUNCTIONS and reference ONLY events listed in EVENTS.
   - If the scaffold suggests a getter that is NOT in FUNCTIONS (e.g., `getValue()`), REPLACE it with a real read from FUNCTIONS that can verify the state change. If no suitable read exists, verify via emitted EVENTS and any observable balances/allowance.

5) Assertions quality
   - NEVER use `expect(result).to.be.ok`.
   - For state-changing calls: assert state changes (storage or balances) and/or emitted events with correct `.withArgs(...)`.
   - For view/pure calls: assert exact return values with `to.equal(...)` (no revert on read-only).
   - If you are NOT certain about a custom error or revert message, use `.to.be.reverted` (no `.with(...)`).

6) ERC20-like conventions (if present in ABI)
   - `transfer(to, amt)`: assert `Transfer` event and balances.
   - `approve(spender, amt)`: assert `Approval` and `allowance`.
   - `transferFrom(from, to, amt)`: call via `token.connect(spender)`, assert `Transfer` and updated `allowance`.

7) Literals and helpers
   - Use bigint literals (`1n`, `100n`) for uint/int.
   - Use `ethers.ZeroAddress` instead of raw `"0x000...0"`.
   - Prefer `ethers.parseUnits("1", 18)` when decimals are 18.

8) Concision and completeness
   - Implement for each function block at least: one happy-path, one revert (when applicable), and minimal boundary checks (zero, max, zero address) when meaningful.
   - Keep the file concise (≤ ~180 lines). Do NOT add unrelated tests.

CRITICAL: Fix these universal errors from PREVIOUS ATTEMPT ERRORS:
CRITICAL ERRORS (must fix):
- Found skipped tests (this.skip / .skip). Must be removed.

Please fix ALL errors above. Pay special attention to:
- Missing variable declarations (owner, addr1, addr2 should be from loadFixture)
- Correct imports and TypeScript syntax
- Proper Chai assertion syntax (.to.be.revertedWith, .to.emit, etc.)

:
- "Cannot find name 'addr1/addr2'" → ALWAYS: const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
- ".revertedWithCustomError" error → USE: .to.be.revertedWith("message")
- ".properAddress" error → USE: .to.be.a('string')
- "File truncated" → ALWAYS end with closing });
- BigInt literal errors → USE: BigInt(0) not 0n

SCAFFOLD (replace ALL TODO_AI with working code; keep titles/structure):

import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";

/**
 * Auto-generated scaffold for MockERC20.
 * ARTIFACT_SOURCE: contracts/MockERC20.sol
 * ARTIFACT_PATH: MockERC20.sol/MockERC20.json
 * ARTIFACT_FQN: contracts/MockERC20.sol:MockERC20
 *
 * FUNCTIONS:
 *   allowance(address,address)->view
 *   approve(address,uint256)->nonpayable
 *   balanceOf(address)->view
 *   decimals()->view
 *   mint(address,uint256)->nonpayable
 *   name()->view
 *   symbol()->view
 *   totalSupply()->view
 *   transfer(address,uint256)->nonpayable
 *   transferFrom(address,address,uint256)->nonpayable
 *
 * EVENTS:
 *   (none)
 *
 * LLM NOTES (follow strictly):
 * - Remove this.skip() and fill TODO_AI blocks when implementing tests.
 * - Use Ethers v6 (no ethers.utils), bigint literals, ethers.ZeroAddress.
 * - View/Pure: assert return values. State-changing: happy path + revert + boundary.
 * - Do NOT introduce functions that are not listed above.
 */

describe("MockERC20 — AI Generated Scaffold", function () {
  async function deployFixture() {
    const [owner, addr1, addr2] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("contracts/MockERC20.sol:MockERC20");
    const contract = await Contract.deploy(BigInt(0));
    await contract.waitForDeployment();
    return { contract, owner, addr1, addr2 };
  }

  it("deployment", async function () {
    const { contract } = await loadFixture(deployFixture);
    expect(await contract.getAddress()).to.be.a('string');
  });


  describe("allowance(address,address)", function () {
    it("happy path", async function () {
      // TODO_AI: Replace this entire comment block with working test code
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // TODO_AI: Call allowance() and add assertions
      this.skip(); // TODO_AI: remove this line when implementing
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("approve(address,uint256)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions (e.g., fund contract if withdrawing)
      // TODO_AI: Act -> call the function with valid inputs
      // TODO_AI: Assert -> expect events/state changes
    });

    it("reverts on invalid input/role", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions
      // TODO_AI: Act -> call function with invalid inputs or unauthorized caller
      // TODO_AI: Assert -> expect revert with specific message
    });

    it("boundary cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test boundary conditions (0, max values, role limits, etc.)
    });
  });

  describe("balanceOf(address)", function () {
    it("happy path", async function () {
      // TODO_AI: Replace this entire comment block with working test code
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // TODO_AI: Call balanceOf() and add assertions
      this.skip(); // TODO_AI: remove this line when implementing
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("decimals()", function () {
    it("happy path", async function () {
      // TODO_AI: Replace this entire comment block with working test code
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // TODO_AI: Call decimals() and add assertions
      this.skip(); // TODO_AI: remove this line when implementing
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("mint(address,uint256)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions (e.g., fund contract if withdrawing)
      // TODO_AI: Act -> call the function with valid inputs
      // TODO_AI: Assert -> expect events/state changes
    });

    it("reverts on invalid input/role", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions
      // TODO_AI: Act -> call function with invalid inputs or unauthorized caller
      // TODO_AI: Assert -> expect revert with specific message
    });

    it("boundary cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test boundary conditions (0, max values, role limits, etc.)
    });
  });

  describe("name()", function () {
    it("happy path", async function () {
      // TODO_AI: Replace this entire comment block with working test code
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // TODO_AI: Call name() and add assertions
      this.skip(); // TODO_AI: remove this line when implementing
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("symbol()", function () {
    it("happy path", async function () {
      // TODO_AI: Replace this entire comment block with working test code
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // TODO_AI: Call symbol() and add assertions
      this.skip(); // TODO_AI: remove this line when implementing
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("totalSupply()", function () {
    it("happy path", async function () {
      // TODO_AI: Replace this entire comment block with working test code
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // TODO_AI: Call totalSupply() and add assertions
      this.skip(); // TODO_AI: remove this line when implementing
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("transfer(address,uint256)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions (e.g., fund contract if withdrawing)
      // TODO_AI: Act -> call the function with valid inputs
      // TODO_AI: Assert -> expect events/state changes
    });

    it("reverts on invalid input/role", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions
      // TODO_AI: Act -> call function with invalid inputs or unauthorized caller
      // TODO_AI: Assert -> expect revert with specific message
    });

    it("boundary cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test boundary conditions (0, max values, role limits, etc.)
    });
  });

  describe("transferFrom(address,address,uint256)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions (e.g., fund contract if withdrawing)
      // TODO_AI: Act -> call the function with valid inputs
      // TODO_AI: Assert -> expect events/state changes
    });

    it("reverts on invalid input/role", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions
      // TODO_AI: Act -> call function with invalid inputs or unauthorized caller
      // TODO_AI: Assert -> expect revert with specific message
    });

    it("boundary cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test boundary conditions (0, max values, role limits, etc.)
    });
  });

});


OUTPUT: Respond with ONE ```ts code block containing the COMPLETE final .spec.ts file. NO explanations.