YOU ARE STRICTLY A Hardhat local unit-test generator (Mocha/Chai + Ethers v6).

PREVIOUS ATTEMPT ERRORS:
CRITICAL ERRORS (must fix):
- Network error: Cannot connect to Ollama at localhost:11434. Is Ollama running?
Original: fetch failed

ðŸš¨ FINAL ATTEMPT - Apply these specific fixes:
- Replace ALL BigInt literals (100n) with ethers.parseEther("100")
- Declare missing variables: const { owner, addr1, addr2, contract } = await loadFixture(deployFixture);
- Use correct Chai syntax: .to.be.revertedWith("message") NOT .revertedWithCustomError
- Fix import: import { ethers } from "hardhat"; (NOT from "ethers")



ðŸš¨ CRITICAL: This is the FINAL attempt. You MUST fix ALL errors shown above.

COMMON ERROR FIXES (apply these patterns):

1. BigInt literals error â†’ Replace: 100n with ethers.parseEther("100")
2. Missing variables â†’ Get from loadFixture: const { owner, addr1, addr2, contract } = await loadFixture(deployFixture);
3. Wrong import â†’ Use: import { ethers } from "hardhat"; (NOT from "ethers" package)
4. Wrong assertions â†’ Use: .to.be.revertedWith("reason") or .to.emit(contract, "EventName")
5. Syntax errors â†’ Check parentheses, semicolons, brackets matching

EXACT PATTERNS TO FOLLOW:
```ts
// âœ… CORRECT deployFixture pattern:
async function deployFixture() {
  const [owner, addr1, addr2] = await ethers.getSigners();
  const MockERC20 = await ethers.getContractFactory("MockERC20");
  const contract = await MockERC20.deploy("Test Token", "TEST", ethers.parseEther("1000000"));
  await contract.waitForDeployment();
  return { contract, owner, addr1, addr2 };
}

// âœ… CORRECT test pattern:
it("should transfer tokens", async function () {
  const { contract, owner, addr1 } = await loadFixture(deployFixture);
  const amount = ethers.parseEther("100"); // NOT 100n
  await contract.transfer(addr1.address, amount);
  expect(await contract.balanceOf(addr1.address)).to.equal(amount);
});
```

MUST:
- Use Hardhat local network with `ethers.getSigners()` and `loadFixture(deployFixture)`.
- Keep `import { ethers } from "hardhat";` exactly as in the scaffold.
- Fix EVERY TypeScript compilation error listed above using the patterns shown.
- Use ethers.parseEther() instead of BigInt literals (100n).
- Declare ALL variables properly from loadFixture (owner, addr1, addr2).
- Use correct Chai assertion methods (.to.be.revertedWith, .to.emit).

NEVER:
- Create providers or wallets (`new ethers.JsonRpcProvider`, `new ethers.Wallet`, RPC URLs, Infura/Alchemy).
- Import from "ethers" package in tests.
- Use `new ethers.Contract(...)` with ABI/address; always deploy via `getContractFactory(...).deploy(...)`.
- Use BigInt literals (100n) - ALWAYS use ethers.parseEther("100").
- Leave any variable undefined - get ALL from loadFixture.
- Use non-existent Chai methods like .revertedWithCustomError or .properAddress.

If you violate any NEVER rule or fail to fix previous errors, your output is invalid.

GOLDEN EXAMPLE (pattern to imitate; do NOT import from "ethers"):
```ts
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
describe("X", function () {
  async function deployFixture() {
    const [owner, a1] = await ethers.getSigners();
    const F = await ethers.getContractFactory("X");
    const c = await F.deploy(); await c.waitForDeployment();
    return { c, owner, a1 };
  }
  it("state change + event", async () => {
    const { c, owner, a1 } = await loadFixture(deployFixture);
    const tx = await c.transfer(a1.address, 1n);
    await expect(tx).to.emit(c, "Transfer").withArgs(owner.address, a1.address, 1n);
    expect(await c.balanceOf(a1.address)).to.equal(1n);
  });
});
```

Target contract: MockERC20

CRITICAL: This is the FINAL retry attempt. You MUST generate WORKING, COMPILABLE code that strictly follows the scaffold structure.

ABI SUMMARY (STRICT - you CANNOT use anything outside this list):
FUNCTIONS:
allowance(address,address)->view
approve(address,uint256)->nonpayable
balanceOf(address)->view
decimals()->view
mint(address,uint256)->nonpayable
name()->view
symbol()->view
totalSupply()->view
transfer(address,uint256)->nonpayable
transferFrom(address,address,uint256)->nonpayable
EVENTS:
LLM NOTES (follow strictly):
- Remove this.skip() and fill TODO_AI blocks when implementing tests.
- Use Ethers v6 (no ethers.utils), bigint literals, ethers.ZeroAddress.
- View/Pure: assert return values. State-changing: happy path + revert + boundary.
- Do NOT introduce functions that are not listed above.

EVENTS:
LLM NOTES (follow strictly):
- Remove this.skip() and fill TODO_AI blocks when implementing tests.
- Use Ethers v6 (no ethers.utils), bigint literals, ethers.ZeroAddress.
- View/Pure: assert return values. State-changing: happy path + revert + boundary.
- Do NOT introduce functions that are not listed above.

ABSOLUTE CONSTRAINTS (non-negotiable)
1) Output format ONLY
   - ONE code block fenced as ```ts ... ``` containing the COMPLETE final file.
   - NO explanations, NO comments outside code, NO multiple blocks.

2) Ethers v6 STRICT
   - Use: `ethers.parseUnits`, `ethers.parseEther`, `ethers.ZeroAddress`, `ethers.MaxUint256`
   - NEVER: `ethers.utils.*`, `ethers.constants.*`
   - Never create external providers or wallets. Tests MUST run on the Hardhat local network using `ethers.getSigners()` and `loadFixture(deployFixture)`.
   - Do NOT import from 'ethers'. Keep the scaffold import: `import { ethers } from "hardhat";`.

3) Scaffold preservation MANDATORY
   - Keep ALL imports, describe/it titles, loadFixture pattern EXACTLY
   - NO new dependencies, NO global hooks, NO extra tests

4) ABI compliance ABSOLUTE
   - Call ONLY functions from FUNCTIONS list
   - Reference ONLY events from EVENTS list
   - If scaffold suggests non-existent function: replace with available ABI functions for equivalent verification
   - Use events + balance checks when direct getters unavailable

5) Assertion quality STRICT
   - NEVER: `expect(result).to.be.ok`
   - State changes: assert concrete state via ABI functions AND/or events with `.withArgs(...)`
   - View calls: assert exact values with `.to.equal(...)`
   - Reverts: use `.to.be.reverted` (avoid specific messages unless 100% certain)

6) ERC20 standard patterns (if applicable)
   - `transfer`: verify `Transfer` event + balance changes
   - `approve`: verify `Approval` event + allowance
   - `transferFrom`: use `.connect(spender)` + verify Transfer + allowance update

7) Types and values
   - Use bigint literals: `1n`, `100n`, `1000000000000000000n`
   - Use `ethers.ZeroAddress` for zero address
   - Use `ethers.parseUnits("amount", decimals)` for token amounts

8) Test completeness
   - Each function: happy path + edge cases + reverts
   - Keep under 200 lines total
   - Focus on critical functionality only

SCAFFOLD (replace ALL TODO_AI, preserve structure):

import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";

/**
 * Auto-generated scaffold for MockERC20.
 * ARTIFACT_SOURCE: contracts/MockERC20.sol
 * ARTIFACT_PATH: MockERC20.sol/MockERC20.json
 * ARTIFACT_FQN: contracts/MockERC20.sol:MockERC20
 *
 * FUNCTIONS:
 *   allowance(address,address)->view
 *   approve(address,uint256)->nonpayable
 *   balanceOf(address)->view
 *   decimals()->view
 *   mint(address,uint256)->nonpayable
 *   name()->view
 *   symbol()->view
 *   totalSupply()->view
 *   transfer(address,uint256)->nonpayable
 *   transferFrom(address,address,uint256)->nonpayable
 *
 * EVENTS:
 *   (none)
 *
 * LLM NOTES (follow strictly):
 * - Remove this.skip() and fill TODO_AI blocks when implementing tests.
 * - Use Ethers v6 (no ethers.utils), bigint literals, ethers.ZeroAddress.
 * - View/Pure: assert return values. State-changing: happy path + revert + boundary.
 * - Do NOT introduce functions that are not listed above.
 */

describe("MockERC20 â€” AI Generated Scaffold", function () {
  async function deployFixture() {
    const [owner, addr1, addr2] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("contracts/MockERC20.sol:MockERC20");
    const contract = await Contract.deploy(0n);
    await contract.waitForDeployment();
    return { contract, owner, addr1, addr2 };
  }

  it("deployment", async function () {
    const { contract } = await loadFixture(deployFixture);
    expect(await contract.getAddress()).to.be.properAddress;
  });


  describe("allowance(address,address)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions if needed
      // TODO_AI: Act -> call allowance() with valid inputs
      // TODO_AI: Assert -> expect correct return values
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("approve(address,uint256)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions (e.g., fund contract if withdrawing)
      // TODO_AI: Act -> call the function with valid inputs
      // TODO_AI: Assert -> expect events/state changes
    });

    it("reverts on invalid input/role", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions
      // TODO_AI: Act -> call function with invalid inputs or unauthorized caller
      // TODO_AI: Assert -> expect revert with specific message
    });

    it("boundary cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test boundary conditions (0, max values, role limits, etc.)
    });
  });

  describe("balanceOf(address)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions if needed
      // TODO_AI: Act -> call balanceOf() with valid inputs
      // TODO_AI: Assert -> expect correct return values
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("decimals()", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions if needed
      // TODO_AI: Act -> call decimals() with valid inputs
      // TODO_AI: Assert -> expect correct return values
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("mint(address,uint256)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions (e.g., fund contract if withdrawing)
      // TODO_AI: Act -> call the function with valid inputs
      // TODO_AI: Assert -> expect events/state changes
    });

    it("reverts on invalid input/role", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions
      // TODO_AI: Act -> call function with invalid inputs or unauthorized caller
      // TODO_AI: Assert -> expect revert with specific message
    });

    it("boundary cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test boundary conditions (0, max values, role limits, etc.)
    });
  });

  describe("name()", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions if needed
      // TODO_AI: Act -> call name() with valid inputs
      // TODO_AI: Assert -> expect correct return values
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("symbol()", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions if needed
      // TODO_AI: Act -> call symbol() with valid inputs
      // TODO_AI: Assert -> expect correct return values
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("totalSupply()", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions if needed
      // TODO_AI: Act -> call totalSupply() with valid inputs
      // TODO_AI: Assert -> expect correct return values
    });

    it("edge cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test edge cases (zero values, max values, etc.)
    });
  });

  describe("transfer(address,uint256)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions (e.g., fund contract if withdrawing)
      // TODO_AI: Act -> call the function with valid inputs
      // TODO_AI: Assert -> expect events/state changes
    });

    it("reverts on invalid input/role", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions
      // TODO_AI: Act -> call function with invalid inputs or unauthorized caller
      // TODO_AI: Assert -> expect revert with specific message
    });

    it("boundary cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test boundary conditions (0, max values, role limits, etc.)
    });
  });

  describe("transferFrom(address,address,uint256)", function () {
    it("happy path", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions (e.g., fund contract if withdrawing)
      // TODO_AI: Act -> call the function with valid inputs
      // TODO_AI: Assert -> expect events/state changes
    });

    it("reverts on invalid input/role", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Arrange -> prepare preconditions
      // TODO_AI: Act -> call function with invalid inputs or unauthorized caller
      // TODO_AI: Assert -> expect revert with specific message
    });

    it("boundary cases", async function () {
      this.skip(); // TODO_AI: remove this.skip() when implementing
      // TODO_AI: Test boundary conditions (0, max values, role limits, etc.)
    });
  });

});


FINAL OUTPUT: Return EXACTLY ONE ```ts code block with the COMPLETE working .spec.ts file. NOTHING ELSE.