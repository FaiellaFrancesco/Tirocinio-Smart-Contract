import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

/**
 * Scaffold generato automaticamente per ETHRN.
 * I blocchi // TODO_AI vanno completati dall'LLM.
 */

describe("ETHRN â€” LLM Scaffold", function () {
  async function deployFixture() {
    const [owner, addr1, addr2] = await ethers.getSigners();
    const Factory = await ethers.getContractFactory("ETHRN");
    // TODO_AI: completa i parametri del costruttore se presenti
    const contract = await Factory.deploy();
    await contract.waitForDeployment();
    return { contract, owner, addr1, addr2 };
  }

  it("deployment di base", async function () {
    const { contract } = await loadFixture(deployFixture);
    expect(await contract.getAddress()).to.properAddress;
  });

  // Eventi in ABI: Approval, AutoNukeLP, BoughtEarly, ETHRNWalletUpdated, ExcludeFromTaxs, ManualNukeLP, OwnershipTransferred, SetAutomatedMarketMakerPair, SwapAndLiquify, Transfer, UpdateUniswapV2Router, marketingWalletUpdated

  
  describe("ETHRN()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.ETHRN();
      // TODO_AI: expect(await contract.ETHRN()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.ETHRN()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("ETHRNWallet()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.ETHRNWallet();
      // TODO_AI: expect(await contract.ETHRNWallet()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.ETHRNWallet()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("_isExcludedMaxTransactionAmount(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract._isExcludedMaxTransactionAmount(addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract._isExcludedMaxTransactionAmount(addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract._isExcludedMaxTransactionAmount(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("allowance(address,address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.allowance(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.allowance(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.allowance(/* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("approve(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.approve(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.approve(/* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("automatedMarketMakerPairs(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.automatedMarketMakerPairs(addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.automatedMarketMakerPairs(addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.automatedMarketMakerPairs(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("balanceOf(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.balanceOf(addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.balanceOf(addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.balanceOf(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("blacklistAccounts(address[],bool)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.blacklistAccounts([] /* TODO_AI */, true /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.blacklistAccounts(/* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("buyETHRNTax()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.buyETHRNTax();
      // TODO_AI: expect(await contract.buyETHRNTax()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.buyETHRNTax()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("buyLiqTax()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.buyLiqTax();
      // TODO_AI: expect(await contract.buyLiqTax()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.buyLiqTax()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("buyMarketingTax()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.buyMarketingTax();
      // TODO_AI: expect(await contract.buyMarketingTax()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.buyMarketingTax()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("buyTotalTaxs()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.buyTotalTaxs();
      // TODO_AI: expect(await contract.buyTotalTaxs()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.buyTotalTaxs()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("decimals()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.decimals();
      // TODO_AI: expect(await contract.decimals()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.decimals()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("decreaseAllowance(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.decreaseAllowance(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.decreaseAllowance(/* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("disableTransferDelay()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.disableTransferDelay();
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.disableTransferDelay()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("earlySellLiqTax()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.earlySellLiqTax();
      // TODO_AI: expect(await contract.earlySellLiqTax()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.earlySellLiqTax()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("earlySellMarketingTax()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.earlySellMarketingTax();
      // TODO_AI: expect(await contract.earlySellMarketingTax()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.earlySellMarketingTax()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("enableEarlySellTax()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.enableEarlySellTax();
      // TODO_AI: expect(await contract.enableEarlySellTax()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.enableEarlySellTax()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("enableTrading()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.enableTrading();
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.enableTrading()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("excludeFromMaxTransaction(address,bool)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.excludeFromMaxTransaction(addr1.address /* TODO_AI */, true /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.excludeFromMaxTransaction(/* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("excludeFromTaxs(address,bool)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.excludeFromTaxs(addr1.address /* TODO_AI */, true /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.excludeFromTaxs(/* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("increaseAllowance(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.increaseAllowance(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.increaseAllowance(/* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("isBlacklisted(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.isBlacklisted(addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.isBlacklisted(addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.isBlacklisted(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("isExcludedFromTaxs(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.isExcludedFromTaxs(addr1.address /* TODO_AI */);
      // TODO_AI: expect(await contract.isExcludedFromTaxs(addr1.address /* TODO_AI */)).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.isExcludedFromTaxs(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("limitsInEffect()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.limitsInEffect();
      // TODO_AI: expect(await contract.limitsInEffect()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.limitsInEffect()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("marketingWallet()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.marketingWallet();
      // TODO_AI: expect(await contract.marketingWallet()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.marketingWallet()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("maxTransactionAmount()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.maxTransactionAmount();
      // TODO_AI: expect(await contract.maxTransactionAmount()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.maxTransactionAmount()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("maxWallet()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.maxWallet();
      // TODO_AI: expect(await contract.maxWallet()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.maxWallet()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("name()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.name();
      // TODO_AI: expect(await contract.name()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.name()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("owner()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.owner();
      // TODO_AI: expect(await contract.owner()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.owner()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("removeLimits()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.removeLimits();
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.removeLimits()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("renounceOwnership()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.renounceOwnership();
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.renounceOwnership()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("sellETHRNTax()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.sellETHRNTax();
      // TODO_AI: expect(await contract.sellETHRNTax()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.sellETHRNTax()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("sellLiqTax()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.sellLiqTax();
      // TODO_AI: expect(await contract.sellLiqTax()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.sellLiqTax()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("sellMarketingTax()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.sellMarketingTax();
      // TODO_AI: expect(await contract.sellMarketingTax()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.sellMarketingTax()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("sellTotalTaxs()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.sellTotalTaxs();
      // TODO_AI: expect(await contract.sellTotalTaxs()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.sellTotalTaxs()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("setAutomatedMarketMakerPair(address,bool)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.setAutomatedMarketMakerPair(addr1.address /* TODO_AI */, true /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.setAutomatedMarketMakerPair(/* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("setEarlySellTax(bool)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.setEarlySellTax(true /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.setEarlySellTax(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("set_ETHRN(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.set_ETHRN(addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.set_ETHRN(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("swapEnabled()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.swapEnabled();
      // TODO_AI: expect(await contract.swapEnabled()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.swapEnabled()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("swapTokensAtAmount()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.swapTokensAtAmount();
      // TODO_AI: expect(await contract.swapTokensAtAmount()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.swapTokensAtAmount()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("symbol()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.symbol();
      // TODO_AI: expect(await contract.symbol()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.symbol()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("tokensForDev()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.tokensForDev();
      // TODO_AI: expect(await contract.tokensForDev()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.tokensForDev()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("tokensForLiquidity()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.tokensForLiquidity();
      // TODO_AI: expect(await contract.tokensForLiquidity()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.tokensForLiquidity()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("tokensForMarketing()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.tokensForMarketing();
      // TODO_AI: expect(await contract.tokensForMarketing()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.tokensForMarketing()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("totalSupply()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.totalSupply();
      // TODO_AI: expect(await contract.totalSupply()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.totalSupply()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("tradingActive()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.tradingActive();
      // TODO_AI: expect(await contract.tradingActive()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.tradingActive()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("transfer(address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.transfer(addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.transfer(/* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("transferDelayEnabled()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.transferDelayEnabled();
      // TODO_AI: expect(await contract.transferDelayEnabled()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.transferDelayEnabled()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("transferFrom(address,address,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.transferFrom(addr1.address /* TODO_AI */, addr1.address /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.transferFrom(/* TODO_AI bad */, /* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("transferOwnership(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.transferOwnership(addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.transferOwnership(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("uniswapV2Pair()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.uniswapV2Pair();
      // TODO_AI: expect(await contract.uniswapV2Pair()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.uniswapV2Pair()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("uniswapV2Router()", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // chiamata di sola lettura
      const result = await contract.uniswapV2Router();
      // TODO_AI: expect(await contract.uniswapV2Router()).to.equal(/* atteso */);
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.uniswapV2Router()
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("updateBuyTaxs(uint256,uint256,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.updateBuyTaxs(1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.updateBuyTaxs(/* TODO_AI bad */, /* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("updateETHRNWallet(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.updateETHRNWallet(addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.updateETHRNWallet(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("updateMarketingWallet(address)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.updateMarketingWallet(addr1.address /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.updateMarketingWallet(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("updateMaxTxnAmount(uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.updateMaxTxnAmount(1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.updateMaxTxnAmount(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("updateMaxWalletAmount(uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.updateMaxWalletAmount(1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.updateMaxWalletAmount(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("updateSellTaxs(uint256,uint256,uint256,uint256,uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.updateSellTaxs(1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */, 1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.updateSellTaxs(/* TODO_AI bad */, /* TODO_AI bad */, /* TODO_AI bad */, /* TODO_AI bad */, /* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("updateSwapEnabled(bool)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.updateSwapEnabled(true /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.updateSwapEnabled(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });


  describe("updateSwapTokensAtAmount(uint256)", function () {
    it("happy path", async function () {
      const { contract, owner, addr1, addr2 } = await loadFixture(deployFixture);
      // transazione che modifica lo stato
      const result = await contract.updateSwapTokensAtAmount(1n /* TODO_AI */);
      // TODO_AI: verifica stato/eventi dopo la tx
    });

    it("reverts su input/ruolo non valido", async function () {
      const { contract } = await loadFixture(deployFixture);
      await expect(
        contract.updateSwapTokensAtAmount(/* TODO_AI bad */)
      ).to.be.reverted; // TODO_AI: .with("MESSAGGIO")
    });

    it("boundary cases", async function () {
      const { contract } = await loadFixture(deployFixture);
      // TODO_AI: 0, max, address(0), limiti ruoli, ecc.
    });

    // TODO_AI: se emette eventi: await expect(tx).to.emit(contract, "Evento").withArgs(...)
  });

});
